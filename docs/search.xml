<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>51单片机入门-点亮LED</title>
    <url>/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%A5%E9%97%A8-%E7%82%B9%E4%BA%AELED.html</url>
    <content><![CDATA[<p>初次接触51单片机，记录下第一个程序，LED跑马灯，源代码如下：</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span><span class="comment">//引入52系列单片机头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//位定义，sbit 标识符 = 地址值</span></span><br><span class="line">sbit led1=P2^<span class="number">0</span>;</span><br><span class="line">sbit led2=P2^<span class="number">1</span>;</span><br><span class="line">sbit led3=P2^<span class="number">2</span>;</span><br><span class="line">sbit led4=P2^<span class="number">3</span>;</span><br><span class="line">sbit led5=P2^<span class="number">4</span>;</span><br><span class="line">sbit led6=P2^<span class="number">5</span>;</span><br><span class="line">sbit led7=P2^<span class="number">6</span>;</span><br><span class="line">sbit led8=P2^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//延迟函数,单位约10微秒，此处利用的是CPU处理的延时，并不准确</span></span><br><span class="line"><span class="comment">//11.0952MHz测得执行时间为0.000009771593，约为9.771593微秒</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">int</span> us)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(us--);<span class="comment">//循环执行，递减</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		led1=<span class="number">0</span>;<span class="comment">//设置低电平点亮LED，断点开始时间0.00042318</span></span><br><span class="line">		delay(<span class="number">10000</span>);<span class="comment">//1秒为1000毫秒1000000微秒，此处为0.1秒，断点结束时间0.09813911</span></span><br><span class="line">		led1=<span class="number">1</span>;<span class="comment">//设置高电平熄灭LED</span></span><br><span class="line">		delay(<span class="number">10000</span>);</span><br><span class="line">		</span><br><span class="line">		led2=<span class="number">0</span>;</span><br><span class="line">		delay(<span class="number">10000</span>);</span><br><span class="line">		led2=<span class="number">1</span>;</span><br><span class="line">		delay(<span class="number">10000</span>);</span><br><span class="line">		</span><br><span class="line">		led3=<span class="number">0</span>;</span><br><span class="line">		delay(<span class="number">10000</span>);</span><br><span class="line">		led3=<span class="number">1</span>;</span><br><span class="line">		delay(<span class="number">10000</span>);</span><br><span class="line">		</span><br><span class="line">		led4=<span class="number">0</span>;</span><br><span class="line">		delay(<span class="number">10000</span>);</span><br><span class="line">		led4=<span class="number">1</span>;</span><br><span class="line">		delay(<span class="number">10000</span>);</span><br><span class="line">		</span><br><span class="line">		led5=<span class="number">0</span>;</span><br><span class="line">		delay(<span class="number">10000</span>);</span><br><span class="line">		led5=<span class="number">1</span>;</span><br><span class="line">		delay(<span class="number">10000</span>);</span><br><span class="line">		</span><br><span class="line">		led6=<span class="number">0</span>;</span><br><span class="line">		delay(<span class="number">10000</span>);</span><br><span class="line">		led6=<span class="number">1</span>;</span><br><span class="line">		delay(<span class="number">10000</span>);</span><br><span class="line">		</span><br><span class="line">		led7=<span class="number">0</span>;</span><br><span class="line">		delay(<span class="number">10000</span>);</span><br><span class="line">		led7=<span class="number">1</span>;</span><br><span class="line">		delay(<span class="number">10000</span>);</span><br><span class="line">		</span><br><span class="line">		led8=<span class="number">0</span>;</span><br><span class="line">		delay(<span class="number">10000</span>);</span><br><span class="line">		led8=<span class="number">1</span>;</span><br><span class="line">		delay(<span class="number">10000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>改进版</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span><span class="comment">//引入52系列单片机头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span><span class="comment">//引入intrins内置函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//延迟函数,单位约10微秒，此处利用的是CPU处理的延时，并不准确</span></span><br><span class="line"><span class="comment">//11.0952MHz测得执行时间为0.000009771593，约为9.771593微秒</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> us)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(us--);<span class="comment">//循环执行，递减</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		P2 = <span class="number">0xfe</span>;<span class="comment">//二进制11111110，对应LED P2^7到0</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			P2 = _crol_(P2,<span class="number">1</span>);<span class="comment">//使LED 从11111110左移一位11111101</span></span><br><span class="line">			delay(<span class="number">5000</span>);<span class="comment">//1秒为1000毫秒1000000微秒，此处为0.05秒，断点结束时间0.09813911</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			P2 = _cror_(P2,<span class="number">1</span>);<span class="comment">//使LED从上方代码执行后的01111111右移一位变为10111111</span></span><br><span class="line">			delay(<span class="number">5000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>知识库</category>
      </categories>
      <tags>
        <tag>嵌入式开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian x86_64平台搭建arm docker环境</title>
    <url>/Debian-x86-64%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BAarm-docker%E7%8E%AF%E5%A2%83.html</url>
    <content><![CDATA[<p>在Debian x86_64平台搭建Docker arm环境的方法</p>
<span id="more"></span>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装QEMU用户模式工具：QEMU将用于在x86_64主机上模拟ARMv8架构</span></span><br><span class="line">apt install qemu binfmt-support qemu-user-static</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用QEMU用户模式支持</span></span><br><span class="line">update-binfmts --enable qemu-arm</span><br><span class="line">update-binfmts --enable qemu-aarch64</span><br></pre></td></tr></table></figure>

<p>使用以上命令便可搭建Docker的arm环境，再使用如下命令即可测试环境是否可以正常使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取debian armv8镜像</span></span><br><span class="line">docker pull arm64v8/debian</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行该镜像，使用了--<span class="built_in">rm</span>参数，会在退出时自动删除容器</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行成功便会自动进入容器shell，使用<span class="built_in">exit</span>即可退出</span></span><br><span class="line">docker run -it --rm arm64v8/debian /bin/bash</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>知识库</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机的学习笔记</title>
    <url>/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h2 id="51单片机的学习及其关联知识"><a href="#51单片机的学习及其关联知识" class="headerlink" title="51单片机的学习及其关联知识"></a>51单片机的学习及其关联知识</h2><span id="more"></span>

<p><strong>开始前的一段话：</strong></p>
<p>求知欲是人类进步的源泉，每接触一项新的知识就像是一滴墨滴在了宣纸上，向着四周疯狂扩散，这种极度的求知欲深深地刺激着我，撕裂我的思维向四周辐射，贪婪地、疯狂地汲取着接触到的每一项知识，这种知识爆炸的感觉带给我成瘾的快感！</p>
<p>对于单片机的起步，始于我小时候的梦想，我想有高度智能的科技、机械围绕着我的生活，我想拥有一个高度智能的工厂，想要无数无数乃至我甚至不知如何形容的科技，我痴迷着这些技术，我疯狂的汲取各种知识，每一次突破一个新的知识面就像是进入一个未知的宇宙！偶然间，我发现我我的梦想可以从两个两个方面入手：</p>
<ol>
<li>软件层面的技术：编程，人工智能等</li>
<li>硬件层面的技术：机械，电路开发等</li>
</ol>
<p>于是我有了方向，向着我想要的极力冲刺！</p>
<p>我于2022.11.21日凌晨开始了51单片机的学习，从茫然无知，到那一滴墨滴在了宣纸上，围绕着单片机开始的知识爆炸让我无比亢奋！从一块小小的51单片机，知识开始爆炸开来，我从未接触过的领域，芯片，电路，逻辑……无数的知识冲刷着我的大脑，无法抑制的激动，发现未知的知识宇宙，我疯狂的汲取着无穷无尽的知识，感叹着人类智慧的结晶！</p>
<p>越是学习，越是发觉自己的无知，知识是无穷无尽的，我永远不可能学完，真的太多太多了！</p>
<p>人生的价值是集体利益，这些伟大的知识我无论学习多少，若不能将其贡献出来，则是对知识、对智慧、对人类乃至对我人生意义的亵渎！</p>
<p>我将尽可能的将我所学的一切，用通俗易懂的语言描述出来，为同样渴望知识、同样有着疯狂求知欲的人们尽一份绵薄之力！</p>
<p>如果你也有着相同的想法，同样渴望知识并为此痴迷，欢迎加入！</p>
<p>如开头所述，求知欲是人类进步的源泉，所以在此，请允许我以<strong>探索者</strong>尊称各位渴望知识的道友，并欢迎您加入到我们，您可以在本页底部找到我的联系方式，因某些原因，建议您使用Telegram进行交流。</p>
<hr>
<p><strong>注意：由于我是边学习边完善文章，所以文章可能存在大量错误，我个人的力量有限，恳请各位探索者开放交流、互换知识，以集体的力量弥补个人的缺陷</strong></p>
<hr>
<h2 id="我使用的单片机"><a href="#我使用的单片机" class="headerlink" title="我使用的单片机"></a>我使用的单片机</h2><p>品牌：普中(PRECHIN)<br>型号：普中51-实验版<br>官方教程：<a href="https://www.bilibili.com/video/BV1RB4y1i71i">https://www.bilibili.com/video/BV1RB4y1i71i</a></p>
<p>在官方教程中，介绍了该开发板的部分元器件：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>4位一体数码管</td>
<td>数字显示</td>
<td>两个4位一体共阴数码管</td>
</tr>
<tr>
<td>LCD1602液晶屏</td>
<td>用于简单内容显示</td>
<td>开发板提供了LCD1602&#x2F;9648&#x2F;12864&#x2F;TFT接口</td>
</tr>
<tr>
<td>8*8LED矩阵</td>
<td>常应用于LED广告牌等</td>
<td>在矩阵旁边提供了编号J24的GND&#x2F;OE&#x2F;VCC三针引脚，跳线帽短接OE&#x2F;VCC可以关闭矩阵节省电源（OE我搜索出来的解释为<em>输出使能控制信号</em>，还请大佬科普补充一下，谢谢）</td>
</tr>
<tr>
<td>LED流水灯</td>
<td>可以用于心形流水灯表白（误）</td>
<td>该开发板提供了8个流水灯</td>
</tr>
<tr>
<td>74HC595A芯片</td>
<td>该芯片用于扩展开发板IO口，驱动8*8点阵</td>
<td>专业名称<em>高速 CMOS 8 位串行移位寄存器</em>其具体资料后续将专门设立电路知识栏目进行解释</td>
</tr>
<tr>
<td>4*4键盘</td>
<td>计算器啥的，挺实用</td>
<td>普普通通</td>
</tr>
<tr>
<td>红外接受</td>
<td>红外遥控嘛，套餐给了遥控器</td>
<td>NEC解码</td>
</tr>
<tr>
<td>DS18B20温度传感器</td>
<td>略</td>
<td>略</td>
</tr>
<tr>
<td>NRF24L01扩展接口</td>
<td>该扩展接口可以用于扩展2.4G无线通信模块</td>
<td>相当NICE的远程通信，几百米的遥控器？</td>
</tr>
<tr>
<td>ASM1117稳压芯片</td>
<td>提供3.3V稳定电压</td>
<td>如视频中所述，大部分传感器为3.3V，所以嘛…</td>
</tr>
<tr>
<td>CH340C芯片</td>
<td>用于USB转TTL通信，该芯片内置晶振</td>
<td>该板设计了4个引脚，分别是UTX-&gt;P30，RTX-&gt;P31，该设计十分优秀！在需要使用串口调试模块时，可以将U&#x2F;RTX针脚接到模块对应引脚，直接使用开发板MicroUSB进行调试，大赞！</td>
</tr>
</tbody></table>
<h2 id="晶振临时科普栏"><a href="#晶振临时科普栏" class="headerlink" title="晶振临时科普栏"></a>晶振临时科普栏</h2><p>因我在学习过程中，对晶振的求知难度较大，特此临时记录！<br>晶振，全称石英晶体振荡器，英文名（quartz oscillator）<br>石英晶振具有高精度高稳度的特性，十分适合用于数字电路的时钟，是数字电路的心脏！</p>
<p><strong>时钟这个概念比较抽象，我尝试将其描述的更加朴素一些：</strong></p>
<p>在计算机中，关和开分别可以代表0和1，在最最原始的逻辑电路中，还没有晶振时，可以通过人工控制开关实现逻辑电路的控制，比如<a href="https://baike.baidu.com/item/%E5%BC%82%E6%88%96%E9%97%A8/9036416">异或门</a></p>
<table>
<thead>
<tr>
<th>A开关</th>
<th>B开关</th>
<th>计算结果</th>
</tr>
</thead>
<tbody><tr>
<td>关</td>
<td>关</td>
<td>0</td>
</tr>
<tr>
<td>开</td>
<td>关</td>
<td>1</td>
</tr>
<tr>
<td>关</td>
<td>开</td>
<td>1</td>
</tr>
<tr>
<td>开</td>
<td>开</td>
<td>0</td>
</tr>
</tbody></table>
<p>于是我们可以通过这种简单逻辑的叠加，做出一些复杂的计算，如加法：x+y<br>设定，检测到<strong>A开B关</strong>一次设定x数值增加1，<strong>A关B开</strong>y数值增加1，那么我们要计算3+2，则需要进行一下操作：</p>
<table>
<thead>
<tr>
<th>给出X值</th>
<th>给出B值</th>
</tr>
</thead>
<tbody><tr>
<td>A开B关重复3次</td>
<td>A关B开重复2次</td>
</tr>
</tbody></table>
<p>由此可以看出，哪怕是及其简单的逻辑处理，也需要非常庞大的开关操作量。<br>因此，懒得一批的人类找到了晶振这玩意儿，<a href="https://zh.wikipedia.org/zh-cn/%E7%9F%B3%E8%8B%B1%E6%99%B6%E4%BD%93%E8%B0%90%E6%8C%AF%E5%99%A8">晶振的原理</a>解释起来有些许复杂，在此我们只需了解，晶振在电路板中工作的原理即可：<br>晶振可以在一定时间内以一定频率发出脉冲，脉冲一词仍有一些难以理解，而有些资料中对此的描述为高低电平的转换，对于一个初学者来说，最讨厌的无非就是看到这些难以理解的名词，在此我将其解释的更加直白一些，不过低电平并不等于0V，低电平只是一个相对较低的电压：<br>低电平：0V电压<br>高电平：5V电压<br>那么脉冲（高低电平转换）在电路中则是，打开开关：低电平（0V&#x3D;没电）转换为高电平（5V&#x3D;来电了），于是，就如我们上文所述，这就像是打开了A开关，利用晶振的这种脉冲，我们便可以在一定时间内实现一定次数的自动开关操作。<br>如果你仔细阅读并理解了，便会发现这真的是一个十分伟大的发明！从此让人类走上了废物(bushi)的道路，躺平~</p>
<p><strong>文章亦是我的笔记，先暂时记录到这里，仍在学习总结中</strong></p>
]]></content>
      <categories>
        <category>知识库</category>
      </categories>
      <tags>
        <tag>嵌入式开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian基础知识【持续更新】</title>
    <url>/Debian%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%90%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E3%80%91.html</url>
    <content><![CDATA[<h1 id="本文将持续更新Debian系统的各类基础知识，欢迎您持续关注，有任何问题可以在本页末尾评论或通过展示的联系方式联系我"><a href="#本文将持续更新Debian系统的各类基础知识，欢迎您持续关注，有任何问题可以在本页末尾评论或通过展示的联系方式联系我" class="headerlink" title="本文将持续更新Debian系统的各类基础知识，欢迎您持续关注，有任何问题可以在本页末尾评论或通过展示的联系方式联系我"></a>本文将持续更新Debian系统的各类基础知识，欢迎您持续关注，有任何问题可以在本页末尾评论或通过展示的联系方式联系我</h1><p><strong>根据红帽的公告，CentOS将不再适合作为生产环境的稳定系统使用，为此我个人建议您尝试著名且优秀的Debian系统</strong></p>
<span id="more"></span>

<blockquote>
<p>2020年12月08日，CentOS官方宣布了停止维护CentOS Linux 8的计划，并推出了CentOS Stream项目。具体信息，请阅读CentOS官方公告。其具体规划如下：</p>
<ul>
<li>CentOS Linux 8作为RHEL 8的复刻版本，生命周期缩短，于2021年12月31日停止更新并停止维护（EOL）。</li>
<li>基于以上官方变更计划，CentOS Linux 8用户将无法获得包括问题修复和功能更新在内的任何软件维护和支持。CentOS官方建议停止维护后：对于开发或测试环境，可以将环境迁移至CentOS Stream版本； 对于生产环境或部署关键业务的系统，建议使用稳定的Red Hat Enterprise Linux。对此，用户需评估以下问题：</li>
<li>CentOS Stream是一个滚动发行的版本，仅为RHEL前置测试版，运用于生产环境时，可能存在一定风险。<br><a href="https://aws.amazon.com/cn/blogs/china/aws-choices-for-centos-after-stopping-maintenance/">亚马逊云科技上在CentOS在停止维护后的几种选择</a></li>
</ul>
</blockquote>
<hr>
<h2 id="Debian-更换国内源"><a href="#Debian-更换国内源" class="headerlink" title="Debian 更换国内源"></a>Debian 更换国内源</h2><p>在使用过阿里云、网易163、清华、中科大源之后，我个人建议更换为中科大源，Debian更换源的方式非常简单，在此非常感谢<a href="https://github.com/snullp">sNullp先生</a>的<a href="https://mirrors.ustc.edu.cn/repogen/">源配置生成器</a>!</p>
<p>在使用该配置生成器之前，你需要先确认你的Debian版本，使用<code>cat /etc/os-release</code>命令，在输出的结果中找到<code>VERSION_CODENAME=bullseye</code>，位于<code>=</code>后面的就是你的版本代号，如图：</p>
<p><img src="https://img.1949hacker.cn/20230301160807.png" alt="20230301160807"></p>
<p>然后打开<a href="https://mirrors.ustc.edu.cn/repogen/">源配置生成器</a>，找到Debian并选择你对应的版本号，如图：</p>
<p><img src="https://img.1949hacker.cn/20230301161044.png" alt="20230301161044"></p>
<p>其中，HTTPS&#x2F;HTTP不必赘述，就是字母意思，而IPv4也很好理解，就是选择IPv4或IPv6地址访问，默认HTTPS和IPv4即可</p>
<p>复制红框中的内容后，回到你的Debian系统，使用<code>vim /etc/apt/sources.list</code>命令编辑apt源配置文件，如果提示<code>-bash: /usr/bin/vim: No such file or directory</code>则是因为你没有安装<code>vim</code>编辑器，我强烈建议你安装<code>vim</code>编辑器，如果暂时无法安装，也可使用<code>nano</code>编辑器，对应命令为<code>nano /etc/apt/sources.list</code>，使用编辑器打开<code>sources.list</code>文件后，如果你是<code>vim</code>编辑器，则可以将光标移到首行，然后按<code>d</code>再按<code>Shift+G</code>即可直接清空内容，然后粘贴你在源配置生成器复制的红框中内容即可，如图：</p>
<p><img src="https://img.1949hacker.cn/20230301161642.png" alt="20230301161642"></p>
<p><code>vim</code>编辑器在编辑完成后按<code>ESC</code>再输入<code>:wq</code>回车即可退出保存，编辑器的操作方式在此不过多赘述。</p>
<p>完成源配置文件的编辑后，还需要使用<code>apt update</code>命令更新源，至此，Debian更换中科大源的教程结束。</p>
<h2 id="Debian-iSCSI挂载卷"><a href="#Debian-iSCSI挂载卷" class="headerlink" title="Debian iSCSI挂载卷"></a>Debian iSCSI挂载卷</h2><p>首先，你需要安装<code>open-iscsi</code>，使用<code>apt install -y open-iscsi</code>进行安装，然后运行<code>iscsiadm -m discovery -t st -p 服务器地址</code>探测服务器发布的卷，如图：</p>
<p><img src="https://img.1949hacker.cn/20230301162849.png" alt="20230301162849"></p>
<p>随后使用<code>iscsiadm -m node -T iqn开头的对应地址 -p 服务器地址 -l</code>即可完成挂载，如图：</p>
<p><img src="https://img.1949hacker.cn/20230301164715.png" alt="20230301164715"></p>
<p>随后使用<code>lsblk</code>命令发现新的磁盘，如图：</p>
<p><img src="https://img.1949hacker.cn/20230301164844.png" alt="20230301164844"></p>
<p>扩展内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自动挂载</span></span><br><span class="line">iscsiadm -m node -T iqn地址:目标 -p 服务器地址:端口 --op update -n node.startup -v automatic</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解除挂载</span></span><br><span class="line">iscsiadm -m node -T iqn地址:目标 -p 服务器地址:端口 -u</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解除所有连接</span></span><br><span class="line">iscsiadm -m node --logoutall=all</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有iscsi连接</span></span><br><span class="line">iscsiadm -m session</span><br></pre></td></tr></table></figure>

<h2 id="Debian-格式化并挂载磁盘以及lvm逻辑卷的使用"><a href="#Debian-格式化并挂载磁盘以及lvm逻辑卷的使用" class="headerlink" title="Debian 格式化并挂载磁盘以及lvm逻辑卷的使用"></a>Debian 格式化并挂载磁盘以及lvm逻辑卷的使用</h2><p>紧跟上文，iscsi挂载后的卷无法直接使用，需要像磁盘一样进行分区及挂载到系统目录</p>
<p>安装parted：<code>apt install -y parted</code></p>
<p>使用<code>parted /dev/设备</code>命令进入磁盘分区管理，随后使用<code>mklable gpt</code>将磁盘设置为优秀的<code>GPT</code>分区表，然后使用<code>mkpart 名称 文件系统 起始扇区 结束地址</code>创建分区，如图：</p>
<p><img src="https://img.1949hacker.cn/20230301165916.png" alt="20230301165916"></p>
<p>其中，2048s是为了将扇区进行对齐，有利于提升性能，而100%则是指定结束地址为最后，100%可以替换为明确的扇区、容量，如9999s（扇区）或100G（容量），同理，起始地址也是如此，如果你需要创建多个分区，则之后的分区起始地址应紧随上一个分区的结束地址。</p>
<p>分区创建完毕后，输入<code>q</code>回车即可退出parted，将分区格式化之后即可挂载使用</p>
<p><strong>但，我在此强烈建议你使用lvm逻辑卷，因为lvm优点有便于容量调整、创建跨区卷等</strong></p>
<p>lvm卷的使用步骤有创建物理卷，创建卷组，创建逻辑卷</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建物理卷</span></span><br><span class="line">pvcreate /dev/设备</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建卷组</span></span><br><span class="line">vgcreate 卷组名 物理卷</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建逻辑卷</span></span><br><span class="line">lvcreate -l +100%FREE -n 逻辑卷名 所属卷组名</span><br></pre></td></tr></table></figure>

<p>示例如图：</p>
<p><img src="https://img.1949hacker.cn/20230301170847.png" alt="20230301170847"></p>
<p>lvm的逻辑卷地址位于<code>/dev/mapper/</code>下，命名格式为<code>卷组名-逻辑卷名</code>，将逻辑卷格式化后即可挂载使用，如图：</p>
<p><img src="https://img.1949hacker.cn/20230301171003.png" alt="20230301171003"></p>
<p>至此，Debian 磁盘分区及lvm逻辑卷教程完毕，如有疑问，欢迎咨询！</p>
<h2 id="Debian访问SMB服务器"><a href="#Debian访问SMB服务器" class="headerlink" title="Debian访问SMB服务器"></a>Debian访问SMB服务器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装cifs-utils</span></span><br><span class="line">apt install cifs-utils</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用mount进行挂载</span></span><br><span class="line">mount -t cifs -o username=$username //$address/$smbname /$mount_point/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例</span></span><br><span class="line">mount -t cifs -o username=user //10.1.1.1/test /smbTest/</span><br></pre></td></tr></table></figure>

<h2 id="apt下载deb包及其依赖的办法"><a href="#apt下载deb包及其依赖的办法" class="headerlink" title="apt下载deb包及其依赖的办法"></a>apt下载deb包及其依赖的办法</h2><p>使用apt install时加上<code>--download-only</code>参数即可实现仅下载而不安装的操作，但是下载的deb包默认是在<code>/var/cache/apt/archives</code>目录中，可以使用<code>-o Dir::Cache::archives=&quot;/&lt;your dir&gt;&quot;</code>参数指定缓存路径。</p>
<p>APT包管理器在执行操作时会使用lock文件来确保系统中只有一个进程在使用APT。partial目录则是APT在下载和安装软件包时使用的临时目录。所以你会发现在你指定的目录中有<code>lock</code>文件和<code>partial</code>目录，删除即可，并无影响。</p>
<p><strong>鉴于你可能是个像我一样有什么大病的强迫症，所以为你提供了禁用lock和partial的办法</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-o APT::Get::Lock_Prohibit=1 # 禁用lock文件</span><br><span class="line">-o Acquire::Pdiffs::NoDownload=true -o Acquire::AllowDowngradeToInsecureRepositories=true -o Acquire::AllowInsecureRepositories=true -o Acquire::NoCDROM=true -o Acquire::NoVerify=true -o Acquire::Check-Valid-Until=false -o Dir::Etc::TrustedParts=&quot;/path/to/trusted/parts&quot; -o Dir::Etc::Trusted=/path/to/trusted/dir # 禁用partial目录</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是的，看花眼了对吧？↓</span></span><br><span class="line">Acquire::Pdiffs::NoDownload=true # 禁用差分包下载</span><br><span class="line">Acquire::AllowDowngradeToInsecureRepositories=true # 允许使用不安全的APT源</span><br><span class="line">Acquire::AllowInsecureRepositories=true # 允许使用不安全的APT源</span><br><span class="line">Acquire::NoCDROM=true # 禁用CD-ROM镜像</span><br><span class="line">Acquire::NoVerify=true # 禁用APT源的GPG验证</span><br><span class="line">Acquire::Check-Valid-Until=false # 禁用APT源的有效期检查</span><br><span class="line">Dir::Etc::TrustedParts=&quot;/path/to/trusted/parts&quot; # 设置APT的可信部件目录</span><br><span class="line">Dir::Etc::Trusted=/path/to/trusted/dir # 设置APT的可信源目录</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以上操作都是为了避免使用partial目录，这些命令可能会降低APT操作的安全性和可靠性</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所以，没什么大病别骚搞，就简单点，下载完了删掉lock和partial即可</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下是我下载docker包的命令示范</span></span><br><span class="line">apt install -o Dir::Cache::archives=&quot;./&quot; --download-only docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>重点！！！</strong></p>
<hr>
<p>上面的办法其实有个很操蛋的地方，如果你的系统已经安装了这个软件包，那么apt并不会为你下载任何deb包，你需要使用下面的办法进行下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将其中的&lt;package-name&gt;替换为你要下载的包，比如nmap</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意！命令中有两处&lt;package-name&gt;</span></span><br><span class="line">apt download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances &lt;package-name&gt; | grep &quot;^\w&quot; | sort -u) &lt;package-name&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下是我下载vim及其依赖的示例</span></span><br><span class="line">apt download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances vim | grep &quot;^\w&quot; | sort -u) vim</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances &lt;package-name&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个命令将返回一个包含软件包及其所有依赖的列表，不包括推荐的软件包和建议的软件包，以及任何冲突、破坏、替换和增强关系</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">grep <span class="string">&quot;^\w&quot;</span>是过滤掉空行和注释行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后使用 <span class="built_in">sort</span> -u 命令去重</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>知识库</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Debian</tag>
      </tags>
  </entry>
  <entry>
    <title>Proxmox-VE 导入SylixOS VMware版</title>
    <url>/Proxmox-VE-%E5%AF%BC%E5%85%A5SylixOS-VMware%E7%89%88.html</url>
    <content><![CDATA[<p>将SylixOS传到服务器</p>
<p>解压SylixOS VMware版，找到其中的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x86_boot.vmdk</span><br><span class="line">x86_main.vmdk</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>将这两个文件上传到服务器，使用qemu-img命令将vmdk虚拟机磁盘转为qcow2格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-img convert -f vmdk -O qcow2 x86_boot.vmdk x86_main.qcow2</span><br><span class="line">qemu-img convert -f vmdk -O qcow2 x86_boot.vmdk x86_boot.qcow2</span><br></pre></td></tr></table></figure>

<p>切换到虚拟化服务器web界面，创建新虚拟机</p>
<ol>
<li><p>操作系统类型：Linux kernel 2.4，不使用任何光盘介质<br> <img src="https://img.1949hacker.cn/20230224155828.png" alt="20230224155828"></p>
</li>
<li><p>创建IDE硬盘，硬盘大小无所谓<br> <img src="https://img.1949hacker.cn/20230224155929.png" alt="20230224155929"></p>
</li>
<li><p>配置CPU，内核数量根据自己需求而定，类型为host<br><img src="https://img.1949hacker.cn/20230224160025.png" alt="20230224160025"></p>
</li>
<li><p>修改网络模型，如果网卡不可用，尝试修改为其他模型<br> <img src="https://img.1949hacker.cn/20230224160056.png" alt="20230224160056"></p>
</li>
</ol>
<p>创建虚拟机的步骤完毕，现在连接到服务器的shell，可以使用web shell或另行连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入到虚拟机配置文件目录</span></span><br><span class="line">cd /etc/pve/qemu-server/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑刚刚创建的ID为125的虚拟机所属配置文件</span></span><br><span class="line">vim 125.conf</span><br></pre></td></tr></table></figure>

<p>原配置文件如下：</p>
<p><img src="https://img.1949hacker.cn/20230224160513.png" alt="20230224160513"></p>
<p>修改第6行ide0开头的内容如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ide0: nfshare:125/x86_boot.qcow2</span><br><span class="line">ide1: nfshare:125/x86_main.qcow2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意！</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中，ide0 ide1务必不要重复，以免冲突</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中，nfshare为我虚拟化服务器所在的存储名称，实际名称以你为准！</span></span><br></pre></td></tr></table></figure>

<p>修改完毕后，将刚刚转化完毕的两个qcow2文件移动到虚拟机磁盘映像所在目录</p>
<p><strong>先删除现有的文件</strong></p>
<p><img src="https://img.1949hacker.cn/20230224160856.png" alt="20230224160856"></p>
<p>随后打开web界面，启动虚拟机即可！</p>
]]></content>
      <categories>
        <category>知识库</category>
      </categories>
      <tags>
        <tag>Proxmox-VE</tag>
        <tag>SylixOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux技巧【持续更新】</title>
    <url>/Linux%E6%8A%80%E5%B7%A7%E3%80%90%E9%9A%8F%E6%97%B6%E6%9B%B4%E6%96%B0%E3%80%91.html</url>
    <content><![CDATA[<blockquote>
<p>若您有任何技术问题，可以通过本站展示的联系方式咨询我</p>
</blockquote>
<span id="more"></span>

<h2 id="Linux查看硬盘SN"><a href="#Linux查看硬盘SN" class="headerlink" title="Linux查看硬盘SN"></a>Linux查看硬盘SN</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将<span class="comment">#替换为你对应的硬盘号 如sda</span></span></span><br><span class="line">lsblk --nodeps -no serial /dev/sd*</span><br></pre></td></tr></table></figure>

<h2 id="Linux解除文件、目录占用"><a href="#Linux解除文件、目录占用" class="headerlink" title="Linux解除文件、目录占用"></a>Linux解除文件、目录占用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用该命令查看占用文件、文件夹的程序<span class="built_in">id</span></span></span><br><span class="line">fuser -cu /你要查询的文件或目录</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例</span></span><br><span class="line">fuser -cu docker-application/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我的输出结果</span></span><br><span class="line">/mnt/TEST/docker-application: 16676m(root) 16702m(root)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中16676m(root)和16702m(root)便是表明该目录由<span class="built_in">id</span>为16676和16702的进程占用</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用<span class="built_in">kill</span> <span class="built_in">id</span>杀死进程后便可删除或使用mount -f强制卸载</span></span><br></pre></td></tr></table></figure>

<h2 id="Linux使用iostat查看磁盘io信息"><a href="#Linux使用iostat查看磁盘io信息" class="headerlink" title="Linux使用iostat查看磁盘io信息"></a>Linux使用iostat查看磁盘io信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用iostat可以查看简要的磁盘io信息</span></span><br><span class="line">iostat</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在此列出部分iostat参数:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-c 查看CPU信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d 仅显示磁盘信息,默认是显示CPU和磁盘信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-x 显示详细信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-k或-m分别是以KB/MB为显示单位</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p显示磁盘及其分区的信息</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">演示实例</span></span><br><span class="line">iostat -x -m 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出结果为每1秒刷新一次以MB为单位的详细信息,一直刷新</span></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           1.12    1.12   20.66    5.81    0.00   71.29</span><br><span class="line"></span><br><span class="line">Device            r/s     rMB/s   rrqm/s  %rrqm r_await rareq-sz     w/s     wMB/s   wrqm/s  %wrqm w_await wareq-sz     d/s     dMB/s   drqm/s  %drqm d_await dareq-sz     f/s f_await  aqu-sz  %util</span><br><span class="line">dm-0             0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00    0.00    0.00   0.00</span><br><span class="line">dm-1             0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00    0.00    0.00   0.00</span><br><span class="line">dm-2             0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00    0.00    0.00   0.00</span><br><span class="line">dm-3             0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00    0.00    0.00   0.00</span><br><span class="line">dm-4             0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00    0.00    0.00   0.00</span><br><span class="line">md123            0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00    0.00    0.00   0.00</span><br><span class="line">md124            0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00    0.00    0.00   0.00</span><br><span class="line">md125            0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00    0.00    0.00   0.00</span><br><span class="line">md126            0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00    0.00    0.00   0.00</span><br><span class="line">md127            0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00    0.00    0.00   0.00</span><br><span class="line">nvme0n1          7.00      0.02     0.00   0.00    6.14     3.43  120.00      1.32     0.00   0.00    1.31    11.30    0.00      0.00     0.00   0.00    0.00     0.00    2.00    2.50    0.21   9.20</span><br><span class="line">sda              2.00      0.00     0.00   0.00   38.00     0.00  920.00     32.91     2.00   0.22    0.52    36.63    0.00      0.00     0.00   0.00    0.00     0.00    2.00   38.50    0.63  63.60</span><br><span class="line">sdb              3.00      0.00     0.00   0.00   35.33     1.33  964.00     34.25     3.00   0.31    0.37    36.38    0.00      0.00     0.00   0.00    0.00     0.00    2.00   38.00    0.54  61.20</span><br><span class="line">sdc              2.00      0.00     0.00   0.00   42.00     0.00  883.00     34.25     3.00   0.34    0.82    39.72    0.00      0.00     0.00   0.00    0.00     0.00    2.00   42.00    0.89  71.20</span><br><span class="line">sdd              2.00      0.00     0.00   0.00   39.50     0.00  956.00     34.21     2.00   0.21    0.36    36.65    0.00      0.00     0.00   0.00    0.00     0.00    2.00   39.00    0.50  59.20</span><br><span class="line">sde              3.00      0.00     0.00   0.00   36.00     1.33  780.00     34.26     1.00   0.13    0.43    44.98    0.00      0.00     0.00   0.00    0.00     0.00    2.00   44.50    0.53  61.20</span><br><span class="line">sdf              2.00      0.00     0.00   0.00   29.50     0.00  772.00     34.21     2.00   0.26    0.44    45.37    0.00      0.00     0.00   0.00    0.00     0.00    2.00   30.00    0.46  58.80</span><br><span class="line">sdg              3.00      0.00     0.00   0.00   22.00     1.33  773.00     34.21     2.00   0.26    0.43    45.31    0.00      0.00     0.00   0.00    0.00     0.00    2.00   33.00    0.46  58.00</span><br><span class="line">sdh              2.00      0.00     0.00   0.00   49.50     0.00  738.00     33.76     3.00   0.40    0.66    46.85    0.00      0.00     0.00   0.00    0.00     0.00    2.00   49.50    0.68  64.80</span><br><span class="line">sdi              3.00      0.00     0.00   0.00   31.33     1.33  680.00     34.21     2.00   0.29    0.86    51.52    0.00      0.00     0.00   0.00    0.00     0.00    2.00   47.00    0.77  66.80</span><br><span class="line">sdj              2.00      0.00     0.00   0.00   44.50     0.00  801.00     34.25     1.00   0.12    0.43    43.79    0.00      0.00     0.00   0.00    0.00     0.00    2.00   44.00    0.52  61.20</span><br><span class="line">sdk              2.00      0.00     0.00   0.00   49.00     0.00  675.00     33.88     3.00   0.44    1.00    51.39    0.00      0.00     0.00   0.00    0.00     0.00    2.00   49.00    0.87  71.20</span><br><span class="line">sdl              2.00      0.00     0.00   0.00   38.50     0.00  697.00     34.62     1.00   0.14    1.20    50.87    0.00      0.00     0.00   0.00    0.00     0.00    2.00   38.50    0.99  76.40</span><br><span class="line">sdm              0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00    0.00    0.00   0.00</span><br><span class="line">sr0              0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00    0.00    0.00   0.00</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中1代表刷新频率,1秒,3代表次数,刷新3次,如果不填写3,则为一直刷新</span></span><br><span class="line">iostat -x -m 1 3</span><br></pre></td></tr></table></figure>

<h3 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h3><table>
<thead>
<tr>
<th>参数</th>
<th>释义</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>显示CPU利用率报告</td>
</tr>
<tr>
<td>–compact</td>
<td>不要将“设备利用率报告”拆分为子报告，以便所有指标都显示在一行中</td>
</tr>
<tr>
<td>-d</td>
<td>显示设备利用率报告</td>
</tr>
<tr>
<td>–dec&#x3D;{ 0 | 1 | 2 }</td>
<td>指定要使用的小数位数（0到2，默认值为2）</td>
</tr>
<tr>
<td>-f</td>
<td>官方对该参数的解释略微复杂,烦请查阅<a href="https://manpages.debian.org/testing/sysstat/iostat.1.en.html#f">官方文档</a></td>
</tr>
<tr>
<td>-g</td>
<td>将所有设备汇总显示,-g参数后面填group_name</td>
</tr>
<tr>
<td>-H</td>
<td>此选项必须与选项-g一起使用，并指示只显示组的全局统计信息，而不显示组中单个设备的统计信息</td>
</tr>
<tr>
<td>-h</td>
<td>该选项将输出结果分类显示,便于阅读</td>
</tr>
<tr>
<td>–human</td>
<td>以人类可读格式打印大小（例如1.0k、1.2M等）。使用此选项显示的单位将取代与度量相关的任何其他默认单位（例如千字节、扇区…）</td>
</tr>
<tr>
<td>-j</td>
<td>在参数后跟(ID&#x2F;LABEL&#x2F;PATH&#x2F;UUID)等,以替换原&#x2F;dev&#x2F;sd*的显示,<a href="https://manpages.debian.org/testing/sysstat/iostat.1.en.html#j">官方文档</a></td>
</tr>
<tr>
<td>-k</td>
<td>以KB为单位进行显示</td>
</tr>
<tr>
<td>-m</td>
<td>以MB为单位进行显示</td>
</tr>
<tr>
<td>-N</td>
<td>显示任何设备映射器设备的注册设备映射器名称。用于查看LVM2统计信息</td>
</tr>
<tr>
<td>-o JSON</td>
<td>以json格式输出结果</td>
</tr>
<tr>
<td>-p</td>
<td>显示磁盘及其分区信息,可以在后跟指定磁盘以显示单个磁盘的分区信息</td>
</tr>
<tr>
<td>–pretty</td>
<td>将报告以更易于阅读的方式显示,同–human</td>
</tr>
<tr>
<td>-s</td>
<td>显示报告的短（窄）版本，该版本应适合80个字符宽的屏幕</td>
</tr>
<tr>
<td>-t</td>
<td>打印显示的每个报告的时间。时间戳格式可能取决于S_TIME_format环境变量的值</td>
</tr>
<tr>
<td>-V</td>
<td>打印iostat版本号</td>
</tr>
<tr>
<td>-x</td>
<td>显示扩展统计信息</td>
</tr>
<tr>
<td>-y</td>
<td>如果在给定的时间间隔内显示多个记录，则省略系统启动后的第一个统计报告</td>
</tr>
<tr>
<td>-z</td>
<td>告诉iostat忽略在采样期间没有活动的任何设备的输出</td>
</tr>
</tbody></table>
<h3 id="输出结果参数解读"><a href="#输出结果参数解读" class="headerlink" title="输出结果参数解读"></a>输出结果参数解读</h3><table>
<thead>
<tr>
<th>参数</th>
<th>释义</th>
</tr>
</thead>
<tbody><tr>
<td>%user</td>
<td>显示在用户级别（应用程序）执行时发生的 CPU 使用率百分比</td>
</tr>
<tr>
<td>%nice</td>
<td>显示在具有良好优先级的用户级别执行时发生的 CPU 使用率百分比</td>
</tr>
<tr>
<td>%system</td>
<td>显示在系统级别（内核）执行时发生的 CPU 使用率百分比</td>
</tr>
<tr>
<td>%iowait</td>
<td>显示系统有未完成的磁盘 I&#x2F;O 请求期间 CPU 或 CPU 空闲的时间百分比</td>
</tr>
<tr>
<td>%steal</td>
<td>显示虚拟机管理程序为另一个虚拟处理器提供服务时虚拟 CPU 或 CPU 非自愿等待所花费的时间百分比</td>
</tr>
<tr>
<td>%idle</td>
<td>显示 CPU 或 CPU 空闲且系统没有未完成的磁盘 I&#x2F;O 请求的时间百分比</td>
</tr>
<tr>
<td>r&#x2F;s</td>
<td>设备每秒完成的读取请求数（合并后）</td>
</tr>
<tr>
<td>rMB&#x2F;s</td>
<td>每秒读字节数,单位随参数-k&#x2F;-m分别对应KB和MB</td>
</tr>
<tr>
<td>rrqm&#x2F;s</td>
<td>每秒合并到设备队列的读取请求数</td>
</tr>
<tr>
<td>%rrqm</td>
<td>在发送到设备之前合并在一起的读取请求的百分比</td>
</tr>
<tr>
<td>r_await</td>
<td>平均每次设备读I&#x2F;O操作的等待时间 (毫秒)</td>
</tr>
<tr>
<td>rareq-sz</td>
<td>向设备发出的读取请求的平均大小（以KB为单位）</td>
</tr>
<tr>
<td>w&#x2F;s</td>
<td>设备每秒完成的写入请求数（合并后）</td>
</tr>
<tr>
<td>wMB&#x2F;s</td>
<td>每秒写字节数,单位随参数-k&#x2F;-m分别对应KB和MB</td>
</tr>
<tr>
<td>wrqm&#x2F;s</td>
<td>每秒合并到设备队列的写入请求数</td>
</tr>
<tr>
<td>%wrqm</td>
<td>在发送到设备之前合并在一起的写入请求的百分比</td>
</tr>
<tr>
<td>w_await</td>
<td>平均每次设备写I&#x2F;O操作的等待时间 (毫秒)</td>
</tr>
<tr>
<td>wareq-sz</td>
<td>向设备发出的写入请求的平均大小（以KB为单位）</td>
</tr>
<tr>
<td>d&#x2F;s</td>
<td>设备每秒完成的丢弃请求数（合并后）</td>
</tr>
<tr>
<td>dMB&#x2F;s</td>
<td>每秒为设备丢弃的扇区数,单位随参数-k&#x2F;-m分别对应KB和MB</td>
</tr>
<tr>
<td>drqm&#x2F;s</td>
<td>每秒排队到设备的合并丢弃请求数</td>
</tr>
<tr>
<td>%drqm</td>
<td>在发送到设备之前合并在一起的丢弃请求的百分比</td>
</tr>
<tr>
<td>d_await</td>
<td>向要服务的设备发出的丢弃请求的平均时间（以毫秒为单位）。这包括队列中的请求所花费的时间以及为它们提供服务所花费的</td>
</tr>
<tr>
<td>dareq-sz</td>
<td>向设备发出的丢弃请求的平均大小（以KB为单位）</td>
</tr>
<tr>
<td>f&#x2F;s</td>
<td>设备每秒完成的刷新请求数（合并后）。这对磁盘执行的刷新请求进行计数。不跟踪分区的刷新请求。在合并之前，刷新操作算作写入操作</td>
</tr>
<tr>
<td>f_await</td>
<td>向要服务的设备发出刷新请求的平均时间（以毫秒为单位）。块层合并刷新请求并且一次最多执行一个。因此刷新操作可能是两倍长：等待当前刷新请求，然后执行它，然后等待下一个</td>
</tr>
<tr>
<td>aqu-sz</td>
<td>向设备发出的请求的平均队列长度,在以前的版本中,此字段称为 avgqu-sz</td>
</tr>
<tr>
<td>%util</td>
<td>向设备发出 I&#x2F;O 请求所用时间的百分比（设备的带宽利用率）。对于串行服务请求的设备，当此值接近 100% 时，就会发生设备饱和。但对于并行处理请求的设备，例如 RAID 阵列和现代 SSD，这个数字并不反映它们的性能限制</td>
</tr>
</tbody></table>
<blockquote>
<p>%iowait的值过高,表示硬盘存在I&#x2F;O瓶颈<br>%idle值高,表示CPU较空闲<br>%idle值高但系统响应慢时,有可能是CPU等待分配内存,此时应加大内存容量<br>%idle值如果持续低于10,那么系统的CPU处理能力相对较低,表明系统中最需要解决的资源是CPU<br>%util 接近 100%，说明产生的I&#x2F;O请求太多，I&#x2F;O系统已经满负荷，该磁盘可能存在瓶颈</p>
<p>该文章内容参考<a href="https://manpages.debian.org/testing/sysstat/iostat.1.en.html">iostat官方文档https://manpages.debian.org/testing/sysstat/iostat.1.en.html</a></p>
</blockquote>
<h2 id="fio测试工具详细教程"><a href="#fio测试工具详细教程" class="headerlink" title="fio测试工具详细教程"></a>fio测试工具详细教程</h2><blockquote>
<p>待完善,先临时记录一条</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fio -name=stress_disk -filename=/mnt/DATA/test/a -size=30T -runtime=240h -bs=1m -direct=1 -rw=randrw -ioengine=libaio -numjobs=12 -group_reporting -iodepth=8 -rwmixwrite=50 -time_based -ramp_time=60s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中name是本次测试任务的名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">filename则为指定测试目录和文件名</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">size则为指定测试文件大小,此处为30T,无论运行多久,该测试文件a都不会超过30T</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">runtime为指定运行时间,240h则为240小时,单位可以为秒s分m时h</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bs为块大小,顺序读写通常为1m,4k则填写4k即可</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">direct有0和1选项,0为使用文件系统缓存,1则为直接操作磁盘</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rw可选的参数有<span class="built_in">read</span>/write/rw/randread/randwrite/randrw,分别为读/写/读写/随机读/随机写/随机读写</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ioengine IO测试引擎,在linux下选择libaio即可</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">numjobs线程数,一般设置为硬盘数量,根据实际需要自行调整</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">group_reporting合并报告,将性能测试结果合并汇报,显示所有硬盘性能测试的总结果</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">iodepth IO队列深度,指定IO队列深度,提高每次请求的IO数量</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rwmixwrite/rwmixread 这两个参数都可以指定,按百分比指定,如rwmixwrite=30则表示写占比30%,只需使用其中一个即可,无需同时指定两个参数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">time_based 设置即便fio写完了指定的size依旧不结束，直至runtime的时间</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ramp_time=60s 设置fio执行任务时的预热时间，可以使性能测试结果更加精确可靠</span></span><br></pre></td></tr></table></figure>

<h2 id="Linux-NFS挂载及使用systemctl自动挂载"><a href="#Linux-NFS挂载及使用systemctl自动挂载" class="headerlink" title="Linux NFS挂载及使用systemctl自动挂载"></a>Linux NFS挂载及使用systemctl自动挂载</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">NFS挂载基础命令及其作用</span></span><br><span class="line">mount -t nfs -o vers=3,rw,hard,sync 10.0.0.100:/mnt/TEST/nfs /mnt/100nfs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount linux挂载命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-t nfs 指定挂载协议为nfs -o也就是options，选项的意思</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vers=3 指定NFS版本，NFSv3</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rw 读写</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hard硬链接</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">补充：soft为软连接，二者的特点是硬链接保障数据安全但需要持续等待服务器响应，软连接的特点是快速响应但如果服务器断开则可能导致数据损坏或丢失</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">简单来说，硬链接适合网络环境较差或数据安全要求严格的场景，软连接适合网络稳定需要快速响应的场景</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">【技术是严谨的，如果我的解释有误烦请立刻指正，十分感谢！】</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">sync</span>，同步写入，写入到磁盘，IO响应较慢但数据安全，async，异步写入，IO响应快，数据安全性低，类似RAID write back</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数指定完成后便是服务器路径和本地路径，格式为 服务器地址:路径 本地路径，如 example:/example /example</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用systemctl管理nfs挂载</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建nfs.service文件【我的环境为Debian 11.6，该文件放在/usr/lib/systemd/system/下】</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2024/1/13更新，因实际使用过程中遇到过网络并未第一时间连通导致的挂载失败，所以在mount操作前增加ping操作</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">原命令为：ExecStart=/usr/bin/mount -t nfs -o vers=3,rw,hard,<span class="built_in">sync</span> 10.0.0.100:/mnt/data /data</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下列代码中10.0.0.100为我的nfs服务器地址，需要替换为你自己的，包括服务器的路径:/mnt/data/storage和挂载路径/mnt/nfs都需要替换为你自己的</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如有问题可以通过文末的联系方式咨询我，或致电昱格400-028-0061</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=auto mount nfs</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/bin/bash -c &#x27;until ping -c1 10.0.0.100 &amp;&gt;/dev/null; do sleep 5; done &amp;&amp; /usr/bin/mount -t nfs -o vers=4,rw,hard,sync 10.0.0.100:/mnt/data/storage /mnt/nfs&#x27;</span><br><span class="line">Restart=no</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载nfs</span></span><br><span class="line">systemctl start nfs.service</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开机自动挂载</span></span><br><span class="line">systemctl enable nfs.service</span><br></pre></td></tr></table></figure>

<h2 id="mdadm管理软RAID阵列"><a href="#mdadm管理软RAID阵列" class="headerlink" title="mdadm管理软RAID阵列"></a>mdadm管理软RAID阵列</h2><p>mdadm全称Multiple Disk and Device Administration（多磁盘和设备管理），是一个Linux软件RAID管理工具，可以使用它来创建各种级别的RAID阵列，包括RAID 0、RAID 1、RAID 5、RAID 6等。</p>
<h3 id="使用mdadm创建RAID的一般步骤："><a href="#使用mdadm创建RAID的一般步骤：" class="headerlink" title="使用mdadm创建RAID的一般步骤："></a>使用mdadm创建RAID的一般步骤：</h3><ol>
<li>安装mdadm软件</li>
</ol>
<p>在大多数Linux发行版中，mdadm已经预装了，如果没有预装，则可以使用<code>sudo apt install mdadm</code>命令进行安装</p>
<ol>
<li><p>准备好磁盘分区，推荐使用<code>parted</code>进行磁盘分区</p>
</li>
<li><p>创建RAID设备</p>
</li>
</ol>
<p>使用mdadm命令创建RAID设备。例如，以下命令将使用指定的磁盘分区创建一个RAID5设备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mdadm --create /dev/md0 --level=5 --raid-devices=3 /dev/sda1 /dev/sdb1 /dev/sdc1</span><br></pre></td></tr></table></figure>

<p>其中，&#x2F;dev&#x2F;md0是要创建的RAID设备的名称，自定义为md开头的设备即可，如<code>md233</code>等，–level&#x3D;5指定RAID级别为5（RAID 5），–raid-devices&#x3D;3指定有3个磁盘参与RAID，&#x2F;dev&#x2F;sda1、&#x2F;dev&#x2F;sdb1和&#x2F;dev&#x2F;sdc1是要组成RAID设备的分区。</p>
<ol start="4">
<li>格式化RAID设备</li>
</ol>
<p>创建RAID设备后，需要对其进行格式化，以便可以在其中存储数据。可以使用mkfs命令格式化RAID设备。例如，以下命令将对RAID设备进行ext4格式化：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkfs.ext4 /dev/md0</span><br></pre></td></tr></table></figure>

<ol>
<li>挂载RAID设备</li>
</ol>
<p>格式化RAID设备后，需要将其挂载到文件系统中，以便可以访问其中的数据。可以使用mount命令将RAID设备挂载到指定的挂载点。例如，以下命令将RAID设备挂载到&#x2F;mnt&#x2F;raid5目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mount /dev/md0 /mnt/raid5</span><br></pre></td></tr></table></figure>

<h3 id="使用mdadm删除RAID的一般步骤："><a href="#使用mdadm删除RAID的一般步骤：" class="headerlink" title="使用mdadm删除RAID的一般步骤："></a>使用mdadm删除RAID的一般步骤：</h3><ol>
<li>卸载RAID设备</li>
</ol>
<p>在删除RAID设备之前，需要先将其从文件系统中卸载。可以使用以下命令卸载挂载在&#x2F;mnt&#x2F;raid0目录的RAID设备：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo umount /mnt/raid5</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>停用RAID设备</li>
</ol>
<p>在删除RAID设备之前，需要停用该设备。可以使用以下命令停用RAID设备：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mdadm --stop /dev/md0</span><br></pre></td></tr></table></figure>

<p>其中，&#x2F;dev&#x2F;md0是要停用的RAID设备的名称。</p>
<ol start="3">
<li>删除RAID设备</li>
</ol>
<p>在停用RAID设备之后，可以使用以下命令删除RAID设备：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mdadm --remove /dev/md0</span><br></pre></td></tr></table></figure>

<p>其中，&#x2F;dev&#x2F;md0是要删除的RAID设备的名称。</p>
<ol start="4">
<li>清除RAID设备元数据</li>
</ol>
<p>在删除RAID设备之后，需要清除RAID设备的元数据，以确保在以后不会误认为该设备是RAID设备。可以使用以下命令清除RAID设备的元数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mdadm --zero-superblock /dev/sda1 /dev/sdb1 /dev/sdc1</span><br></pre></td></tr></table></figure>

<p>其中，&#x2F;dev&#x2F;sda1、&#x2F;dev&#x2F;sdb1和&#x2F;dev&#x2F;sdc1是原始磁盘分区，是用来创建RAID设备的。使用该命令清除元数据可以确保将来使用这些分区时不会出现问题。</p>
<p>以上就是删除mdadm创建的RAID设备的步骤。请注意，在删除RAID设备之前，务必备份其中的数据，以免误删除数据。</p>
<h2 id="fstab自动挂载失败导致无法开机的解决办法"><a href="#fstab自动挂载失败导致无法开机的解决办法" class="headerlink" title="fstab自动挂载失败导致无法开机的解决办法"></a>fstab自动挂载失败导致无法开机的解决办法</h2><p>首先，fstab的挂载强烈建议使用UUID，可以通过<code>blkid</code>命令查询UUID，UUID是不会变的，但是你的sda可能变成sdb，尤其是在iscsi挂载时</p>
<p>通常<code>fstab</code>的挂载命令中有一条<code>default</code>，改为<code>nofail</code>即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">原挂载方式</span></span><br><span class="line">/dev/sdc1 /mnt/data xfs default 0 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改为nofail，该命令的作用为在挂载时如果失败则不会阻止系统启动。使用UUID挂载</span></span><br><span class="line">UUID=&quot;4048c1b1-1bde-49ee-8d40-8d437ce32783&quot; /mnt/data xfs nofail 0 0</span><br></pre></td></tr></table></figure>

<p><strong>注意！修改fstab后强烈建议使用<code>mount -a</code>来测试挂载是否正常</strong></p>
<p><strong>使用<code>blkid</code>查询UUID时，如果你的设备过多，可以指定某个设备或其分区查询，这样还可避免粗心错误挂载了设备本身，例如<code>blkid /dev/sdc1</code>这样查询的便是sdc设备的sdc1分区</strong></p>
<h2 id="Linux使用stress-ng让CPU始终维持在百分比占用的办法"><a href="#Linux使用stress-ng让CPU始终维持在百分比占用的办法" class="headerlink" title="Linux使用stress-ng让CPU始终维持在百分比占用的办法"></a>Linux使用stress-ng让CPU始终维持在百分比占用的办法</h2><p>首先，你需要安装stress-ng，同时，也推荐你使用dstat观察CPU占用率<br>这两个软件通过<code>apt install stress-ng dstat</code>即可安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stress-ng --cpu &lt;线程数&gt; --cpu-method matrixprod --cpu-load &lt;百分比数字&gt; --matrix-size 400 --timeout 0 --metrics-brief</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数解析</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--cpu &lt;线程数&gt;是使用多少个线程</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--cpu-load &lt;百分比数字&gt;是占用率维持在多少</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面这个两个参数需要配合使用，假设你的CPU是4核8线程，想要达到整个CPU50%占用率</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">则需要设置为--cpu 8 --cpu-load 50或者是--cpu 4 --cpu-load 100，总占用率=线程数*百分比</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--cpu-method matrixprod 这个选项指定了要使用的 CPU 负载类型，这里设置为 matrixprod，表示使用矩阵乘法来进行负载测试</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--matrix-size 400 这个选项指定了矩阵乘法中的矩阵大小，这里设置为 400x400，表示要进行 400x400 的矩阵乘法计算</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--<span class="built_in">timeout</span> 0表示一直运行，也可设置为秒s分m时h的自定义时间如120s，也可写为2m</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--metrics-brief 这个选项指定了在结束测试后输出的统计信息，这里设置为 brief，表示只输出简要的统计信息 -- 如果只是单纯为了占用CPU，可以不用这个</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例，56核112线程的CPU使其占用维持在64%</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以采用两个方案，控制满载的线程，或者直接设定总负载率</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为我需要其余线程用于测试，所以下面采用的是控制满载线程的方式，使剩余线程空闲</span></span><br><span class="line">stress-ng --cpu 72 --cpu-method matrixprod --cpu-load 100 --matrix-size 400 --timeout 0 --metrics-brief</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">补充，因为stress-ng需要使用内存，考虑到你可能需要限制占用的内存量，可以使用以下方式实现</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定--vm-bytes参数，该参数的作用是每个线程能使用的内存大小</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--vm-bytes参数允许的范围是4KB-256TB，默认似乎是20MB</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我修改后的测试代码如下：</span></span><br><span class="line">stress-ng --cpu 72 --cpu-method matrixprod --cpu-load 100 --vm-bytes 4K --matrix-size 400 --timeout 0 --metrics-brief</span><br></pre></td></tr></table></figure>

<h2 id="Linux使用vsftp部署-FTP服务器的办法"><a href="#Linux使用vsftp部署-FTP服务器的办法" class="headerlink" title="Linux使用vsftp部署 FTP服务器的办法"></a>Linux使用vsftp部署 FTP服务器的办法</h2><hr>
<h2 id="本站新发布了使用docker部署-vsftpd的方法，推荐使用docker部署，请查看文章《使用Docker部署vsftpd》"><a href="#本站新发布了使用docker部署-vsftpd的方法，推荐使用docker部署，请查看文章《使用Docker部署vsftpd》" class="headerlink" title="本站新发布了使用docker部署 vsftpd的方法，推荐使用docker部署，请查看文章《使用Docker部署vsftpd》"></a>本站新发布了使用docker部署 vsftpd的方法，推荐使用docker部署，请查看文章《使用Docker部署vsftpd》</h2><p>第一步，根据你的发行版使用<code>apt</code>或<code>yum</code>及其他命令，安装<code>vsftp</code>软件包</p>
<p><img src="https://img.1949hacker.cn//20230906162643.png" alt="20230906162643"></p>
<p>第二步，编辑<code>vsftpd.conf</code>文件</p>
<p><img src="https://img.1949hacker.cn//20230906162829.png" alt="20230906162829"></p>
<p>确认以下内容：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>anonymous_enable&#x3D;NO</td>
<td>禁止匿名访问</td>
</tr>
<tr>
<td>local_enable&#x3D;YES</td>
<td>允许本地用户登录</td>
</tr>
<tr>
<td>write_enable&#x3D;YES</td>
<td>允许用户上传文件</td>
</tr>
<tr>
<td>chroot_local_user&#x3D;YES</td>
<td>限制用户的根目录为其主目录</td>
</tr>
</tbody></table>
<p>第三步，添加以下行以指定允许登录的用户列表，这里我们创建一个名为<code>test</code>的用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">userlist_enable=YES</span><br><span class="line">userlist_file=/etc/vsftpd.userlist</span><br><span class="line">userlist_deny=NO</span><br><span class="line">local_root=指定目录</span><br></pre></td></tr></table></figure>

<p>编辑完成后保存退出</p>
<p><img src="https://img.1949hacker.cn//20230906171602.png" alt="20230906171602"></p>
<p>第四步，创建指定用户，此处以<code>abc</code>用户作为演示</p>
<p>使用<code>useradd abc</code>创建<code>abc</code>用户</p>
<p><strong>各发行版创建过程并不一致，请以你的发行版为准！</strong></p>
<p><img src="https://img.1949hacker.cn//20230906171833.png" alt="20230906171833"></p>
<p>使用<code>mkdir</code>命令，创建一个用于ftp的目录</p>
<p>修改该目录所有者及所有组权限为<code>abc</code>，并赋予755权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因vsftp安全策略原因，用户主目录，也就是/opt/ftp，将无法具备写权限，所以需要创建子目录用于ftp文件传输</span></span><br><span class="line">mkdir -p /opt/ftp/data</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置abc用户主目录为/opt/ftp/abc</span></span><br><span class="line">usermod -d /opt/ftp abc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">移除abc用户主目录/opt/ftp的写权限，否则无法登录</span></span><br><span class="line">chmod a-w /opt/ftp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改目录所有者及所有组</span></span><br><span class="line">chown -R abc:abc /opt/ftp/data</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改目录权限为755</span></span><br><span class="line">chmod -R 755 /opt/ftp/data</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">此处/opt/ftp则为上文中local_root=指定目录：local_root=/opt/ftp</span></span><br></pre></td></tr></table></figure>

<p>根据上文的<code>userlist_file=/etc/vsftpd.userlist</code>，在<code>/etc</code>目录下创建<code>vsftpd.userlist</code>文件并编辑内容</p>
<p><img src="https://img.1949hacker.cn//20230906164114.png" alt="20230906164114"></p>
<p>输入用户名<code>abc</code>退出保存即可，如需添加多个用户，每行一个即可</p>
<p><img src="https://img.1949hacker.cn//20230906171208.png" alt="20230906171208"></p>
<p>第五步，重启<code>vsftp</code>服务</p>
<p><code>systemctl restart vsftpd</code></p>
<p><img src="https://img.1949hacker.cn//20230906164916.png" alt="20230906164916"></p>
<p>如果需要让该ftp用户<code>abc</code>无法登录到系统，仅访问ftp，则按照以下步骤设置</p>
<p>首先，找到系统中的<code>/etc/base</code>或<code>/etc/shells</code>，通常系统中会同时存在这两个文件，需要分别查看这两个文件，选择有内容的那一个，如图，<code>/etc/bash</code>为空，则该文件无效</p>
<p><img src="https://img.1949hacker.cn//20230906183203.png" alt="20230906183203"></p>
<p>编辑有文件的<code>/etc/shells</code>，在文件末尾添加<code>/bin/false</code>后保存退出</p>
<p><img src="https://img.1949hacker.cn//20230906183254.png" alt="20230906183254"></p>
<p>随后使用<code>usermod -s /bin/false abc</code>即可使<code>abc</code>用户无法登录到系统，但可正常登录ftp，若ftp依旧无法登录，使用上文中的方式重启<code>vsftp</code>服务即可。</p>
]]></content>
      <categories>
        <category>知识库</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode编写markdown的插件推荐</title>
    <url>/vscode%E7%BC%96%E5%86%99markdown%E7%9A%84%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90.html</url>
    <content><![CDATA[<h1 id="使用-VScode-编写-Markdown-的插件推荐及其技巧"><a href="#使用-VScode-编写-Markdown-的插件推荐及其技巧" class="headerlink" title="使用 VScode 编写 Markdown 的插件推荐及其技巧"></a>使用 VScode 编写 Markdown 的插件推荐及其技巧</h1><span id="more"></span>

<h2 id="Markdown-插件推荐"><a href="#Markdown-插件推荐" class="headerlink" title="Markdown 插件推荐"></a>Markdown 插件推荐</h2><ul>
<li>Markdown Preview Enhanced</li>
<li>Markdown PDF</li>
<li>LaTeX Workshop</li>
<li>Paste Image</li>
<li>Markdown All in One</li>
</ul>
<h2 id="Markdown-插件详细介绍"><a href="#Markdown-插件详细介绍" class="headerlink" title="Markdown 插件详细介绍"></a>Markdown 插件详细介绍</h2><h3 id="Markdown-Preview-Enhanced"><a href="#Markdown-Preview-Enhanced" class="headerlink" title="Markdown Preview Enhanced"></a>Markdown Preview Enhanced</h3><p>该插件可以对 Markdown 源码进行实时渲染预览，通过配置插件的</p>
<blockquote>
<p>Markdown-preview-enhanced: Automatically Show Preview Of Markdown Being Edited</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> Automatically show preview of markdown being edited.</li>
</ul>
</blockquote>
<p>可以实现点击 md 文件编辑的同时自动打开实时渲染界面</p>
<p><img src="https://img.1949hacker.cn//2022-10-14-16-18-21.png" alt="2022-10-14-16-18-21"></p>
<h3 id="Markdown-PDF"><a href="#Markdown-PDF" class="headerlink" title="Markdown PDF"></a>Markdown PDF</h3><p>该插件可以将 md 文件转换为<strong>pdf、html、png、jpeg</strong>四种格式，配合 vscode 快捷键<code>Ctrl+Shift+P</code>并输入<code>&gt;export (pdf)</code>后回车即可将当前打开的 md 文件转换为 PDF 格式，替换<code>(pdf)</code>中的<code>pdf</code>为<code>html、png、jpeg</code>其中任意一种，即可导出对应的格式<br>使用<code>&gt;export (all: pdf,html,png,jpeg)</code>可以一次性导出为 4 种格式</p>
<h3 id="LaTeX-Workshop"><a href="#LaTeX-Workshop" class="headerlink" title="LaTeX Workshop"></a>LaTeX Workshop</h3><p>该插件可以使 vscode 支持 latex 数学公式代码<br>示例如下：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line">M =</span><br><span class="line"><span class="keyword">\begin</span>&#123;pmatrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 0 <span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1</span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;pmatrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 0 <span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1</span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>LaTeX 语法可以自行搜索，此处给出一条参考链接：<a href="http://www.uinio.com/Math/LaTex/">LaTeX 语法</a></p>
<h3 id="Paste-Image"><a href="#Paste-Image" class="headerlink" title="Paste Image"></a>Paste Image</h3><p>使用 Paste Image 可以快速将粘贴板中的图片粘贴到 Markdown 源码中，快捷键是<code>Ctrl+Shift+V</code><br>示例：</p>
<p><img src="https://img.1949hacker.cn//2022-10-14-16-37-29.png" alt="2022-10-14-16-37-29"></p>
<p>Paste Image 默认会将图片复制到当前 md 文件所在目录，并根据<strong>年月日时分秒</strong>自动命名，可以在 vscode 设置中找到 paste image 的配置参数进行修改<br>图片自动复制的目录参数为：</p>
<p><img src="https://img.1949hacker.cn//2022-10-14-16-42-28.png" alt="2022-10-14-16-42-28"></p>
<p>其中<code>$&#123;currentFileDir&#125;</code>为当前 md 文件所在目录，可以修改为项目根目录<code>$&#123;projectRoot&#125;</code>，还可在二者后面跟上<code>\</code>，如<code>$&#123;currentFileDir&#125;/md_img</code>，则会将图片复制到当前 md 文件所在目录下的<strong>md_img</strong>目录，若没有<strong>md_img</strong>目录则自动创建</p>
<p><strong>修改图片保存路径后需要修改<code>Paste Image: Prefix</code>，以便路径可以正常匹配</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Paste Image: Prefix</span><br><span class="line">The string prepend to the resolved image path before paste.</span><br></pre></td></tr></table></figure>

<p>如上文示例，将图片目录自定义为当前目录中<code>/md_img</code>文件夹，那么此处需修改为：</p>
<p><img src="https://img.1949hacker.cn//20221027132513.png" alt="20221027132513"></p>
<p>当使用<code>Ctrl+Shift+V</code>粘贴后，图片路径会自动设定为<code>md_img/图片名称</code></p>
<p>图片自动命名的参数为：</p>
<p><img src="https://img.1949hacker.cn//2022-10-14-16-45-50.png" alt="2022-10-14-16-45-50"></p>
<p>其中<code>Y-MM-DD-HH-mm-ss</code>为<strong>年-月-日-时-分-秒</strong>，该参数采用的是<strong>Moment.js</strong><br><a href="https://momentjs.com/#/displaying/format">Moment.js 语法教程</a></p>
<h3 id="Markdown-All-in-One"><a href="#Markdown-All-in-One" class="headerlink" title="Markdown All in One"></a>Markdown All in One</h3><p>该插件可以使vscode自动补全markdown语法，如使用<code>- 无序列表</code>时，回车将在下一行自动补全<code>- </code><br>示例如图：</p>
<p><img src="https://img.1949hacker.cn//2022-10-14-16-55-11.png" alt="2022-10-14-16-55-11"></p>
<p>基于vscode的特点，按下<code>Ctrl+Shift+P</code>调出控制台后，可以使用<strong>maio</strong>的缩写快速筛出本插件的命令，如图：</p>
<p><img src="https://img.1949hacker.cn//2022-10-14-17-00-34.png" alt="2022-10-14-17-00-34"></p>
<p><a href="https://markdown-all-in-one.github.io/guide/#features">Markdown All in One官网详细介绍</a></p>
]]></content>
      <categories>
        <category>知识库</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Proxmox-VE系统创建UEFI虚拟机需要单独添加EFI磁盘的问题</title>
    <url>/%E5%85%B3%E4%BA%8EProxmox-VE%E7%B3%BB%E7%BB%9F%E5%88%9B%E5%BB%BAUEFI%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9C%80%E8%A6%81%E5%8D%95%E7%8B%AC%E6%B7%BB%E5%8A%A0EFI%E7%A3%81%E7%9B%98%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<blockquote>
<p>在传统物理机上，如需使用UEFI引导，仅仅需要在硬盘上创建EFI分区即可，无论是Windows还是Linux均是如此，但在使用Proxmox-VE创建虚拟机时，却需要额外添加EFI磁盘，对此提出疑问并进行探讨。</p>
</blockquote>
<span id="more"></span>

<p>直接在网络上搜寻并无相关信息，查询<a href="https://pve.proxmox.com/wiki/Qemu/KVM_Virtual_Machines">官方wiki</a>得到如下解释：</p>
<p>BIOS 和 UEFI</p>
<p>为了正确模拟计算机，QEMU 需要使用固件。在通常称为 BIOS 或 (U)EFI 的普通 PC 上，它作为启动 VM 时的第一步执行。它负责进行基本的硬件初始化，并为操作系统提供固件和硬件接口。默认情况下，QEMU 为此使用SeaBIOS，这是一个开源的 x86 BIOS 实现。SeaBIOS 是大多数标准设置的不错选择。</p>
<p>某些操作系统（例如 Windows 11）可能需要使用 UEFI 兼容实现。在这种情况下，您必须使用OVMF，它是一种开源 UEFI 实现。</p>
<p>在其他情况下，SeaBIOS 可能不是理想的启动固件，例如，如果您想进行 VGA 直通。</p>
<p>如果要使用 OVMF，需要考虑以下几点：</p>
<p>为了保存引导顺序之类的东西，需要有一个 EFI 磁盘。该磁盘将包含在备份和快照中，并且只能有一个。</p>
<p>您可以使用以下命令创建这样的磁盘：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qm set &lt;vmid&gt; -efidisk0 &lt;storage&gt;:1,format=&lt;format&gt;,efitype=4m,pre-enrolled-keys=1</span><br></pre></td></tr></table></figure>

<p>其中<strong>storage</strong>是您希望拥有磁盘的存储，而<strong>format</strong>是存储支持的格式。或者，您可以通过VM 硬件部分中的添加 EFI 磁盘的 Web 界面创建这样的磁盘。</p>
<p>efitype选项指定应使用哪个版本的 OVMF 固件。对于新的 VM，这应该始终是4m，因为它支持安全启动并且分配了更多空间来支持未来的开发（这是 GUI 中的默认值）。</p>
<p>pre-enroll-keys指定 efidisk 是否应预加载特定于发行版和 Microsoft 标准安全启动密钥。它还默认启用安全启动（尽管它仍然可以在 VM 的 OVMF 菜单中禁用）。</p>
<p>笔记	如果要在现有 VM（仍使用2m efidisk）中开始使用安全启动，则需要重新创建 efidisk。为此，删除旧的 ( <code>qm set &lt;vmid&gt; -delete efidisk0</code> ) 并添加一个新的，如上所述。这将重置您在 OVMF 菜单中所做的任何自定义配置！<br>当使用带有虚拟显示器的 OVMF（没有 VGA 直通）时，您需要在 OVMF 菜单中设置客户端分辨率（您可以在启动期间按 ESC 按钮到达），或者您必须选择 SPICE 作为显示类型.</p>
<hr>
<p>为了保存引导顺序？或许是类似于物理机上，启动菜单中除了UEFI的硬盘启动项外，还有一个额外的操作系统名称的启动项？如<code>Windows Boot Manager</code>或是<code>Debian</code></p>
<p>EFI磁盘 &#x3D; 操作系统引导项？</p>
]]></content>
      <categories>
        <category>知识库</category>
      </categories>
      <tags>
        <tag>Proxmox-VE</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>将二进制可执行程序构建为deb包</title>
    <url>/%E5%B0%86%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%9E%84%E5%BB%BA%E4%B8%BAdeb%E5%8C%85.html</url>
    <content><![CDATA[<p>构建deb包所需依赖：<br><code>apt install dh-make</code></p>
<span id="more"></span>

<p>第一步，创建项目目录，项目目录名称格式应为<code>包名-版本号</code>如<code>aptdownloader-1.0.0</code></p>
<p>进入项目目录<code>cd aptdownloader-1.0.0</code>，使用<code>dh_make --createorig</code>命令创建项目文件，并根据提示选择包类型<code>single, indep, library, python</code>，示例中创建的是<code>single</code>类型，所以按<code>s</code>，紧接着确认项目信息，确认按y，退出按q，项目信息如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>翻译</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>Maintainer Name</td>
<td>维护人员名称</td>
<td>根据系统<code>DEBFULLNAME</code>自动获取</td>
</tr>
<tr>
<td>Email-Address</td>
<td>电子邮件地址（邮箱）</td>
<td>根据系统<code>DEBEMAIL</code>自动获取</td>
</tr>
<tr>
<td>Date</td>
<td>日期</td>
<td>自动生成</td>
</tr>
<tr>
<td>Package Name</td>
<td>包名称</td>
<td>根据当前项目目录名称生成<code>aptdownloader</code></td>
</tr>
<tr>
<td>Version</td>
<td>版本</td>
<td>根据当前项目目录名称生成<code>-1.0.0</code></td>
</tr>
<tr>
<td>License</td>
<td>许可证</td>
<td>自动生成</td>
</tr>
<tr>
<td>Package Type</td>
<td>包类型</td>
<td>根据s&#x2F;i&#x2F;l&#x2F;p选择生成</td>
</tr>
</tbody></table>
<p>维护人员名称修改方式：<code>export DEBFULLNAME=&quot;Your Name&quot;</code><br>电子邮件地址修改方式：<code>export DEBEMAIL=&quot;your.email@example.com&quot;</code></p>
<p>修改后再运行<code>dh_make --createorig</code>便可看到修改后的信息。</p>
<p><strong>注：项目目录名称必须严格按照<code>包名-版本号</code>命名，否则dh_make会报错</strong></p>
<p><img src="https://img.1949hacker.cn//20231017163920.png" alt="20231017163920"></p>
<p>上述命令执行完毕后会生成<code>debian</code>目录，其中需要修改的是<code>control</code>和<code>rules</code>，以及创建<code>install</code>文件</p>
<p><strong>本文因只需要将二进制可执行程序打包为deb，所以采用默认<code>rules</code>即可，故不对rules进行讲解</strong></p>
<p><code>control</code>文件内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Source: test</span><br><span class="line">Section: unknown</span><br><span class="line">Priority: optional</span><br><span class="line">Maintainer: root &lt;root@localhost.localdomain&gt;</span><br><span class="line">Rules-Requires-Root: no</span><br><span class="line">Build-Depends:</span><br><span class="line"> debhelper-compat (= 13),</span><br><span class="line">Standards-Version: 4.6.2</span><br><span class="line">Homepage: &lt;insert the upstream URL, if relevant&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Vcs-Browser: https://salsa.debian.org/debian/test</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Vcs-Git: https://salsa.debian.org/debian/test.git</span></span><br><span class="line"></span><br><span class="line">Package: test</span><br><span class="line">Architecture: any</span><br><span class="line">Depends:</span><br><span class="line"><span class="meta prompt_"> $</span><span class="language-bash">&#123;shlibs:Depends&#125;,</span></span><br><span class="line"><span class="meta prompt_"> $</span><span class="language-bash">&#123;misc:Depends&#125;,</span></span><br><span class="line">Description: &lt;insert up to 60 chars description&gt;</span><br><span class="line"> &lt;Insert long description, indented with spaces.&gt;</span><br></pre></td></tr></table></figure>

<p>这里直接给出我的修改结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Source: aptdownloader</span><br><span class="line">Section: utils</span><br><span class="line">Priority: optional</span><br><span class="line">Maintainer: Vladimir Yang &lt;scepter@1949hacker.cn&gt;</span><br><span class="line">Build-Depends: debhelper-compat (= 13)</span><br><span class="line">Standards-Version: 4.5.1</span><br><span class="line">Homepage: https://1949hacker.cn</span><br><span class="line"></span><br><span class="line">Rules-Requires-Root: no</span><br><span class="line"></span><br><span class="line">Package: aptdownloader</span><br><span class="line">Architecture: any</span><br><span class="line">Depends: $&#123;shlibs:Depends&#125;, $&#123;misc:Depends&#125;, apt-rdepends (&gt;= 1.0)</span><br><span class="line">Description: A tool for downloading apt packages and their dependencies.</span><br><span class="line"> Use &#x27;aptdownloader &lt;package name&gt;&#x27; to download the software package and its dependencies to the current directory.</span><br><span class="line"> example:</span><br><span class="line">    aptdownloader docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure>

<p>其中手动修改的内容有：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>修改为</th>
</tr>
</thead>
<tbody><tr>
<td>Maintainer</td>
<td>姓名 电子邮箱</td>
</tr>
<tr>
<td>Homepage</td>
<td>建议修改为该项目的介绍网页</td>
</tr>
<tr>
<td>Depends</td>
<td>该项较为关键，除初始的<code>$&#123;shlibs:Depends&#125;, $&#123;misc:Depends&#125;</code>外，如果你的项目依赖额外的deb包，则需要在此注明，以逗号分隔</td>
</tr>
<tr>
<td>Description</td>
<td>冒号后面写不超过60个字符的简介，然后换行缩进1个空格再写完整描述</td>
</tr>
</tbody></table>
<p><code>install</code>文件决定了你的程序放到哪个目录，本文的示例将<code>aptdownloader</code>文件放到<code>/usr/bin</code>目录，则<code>install</code>文件内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aptdownloader usr/bin</span><br></pre></td></tr></table></figure>

<p>将你的程序放到项目的根目录，例如我的项目名为<code>aptdownloader-1.0.0</code>则我的二进制可执行程序<code>aptdownloader</code>路径为<code>aptdownloader-1.0.0/aptdownloader</code>，随后在项目根目录运行命令<code>dpkg-buildpackage -us -uc -nc</code>，随后便会在项目目录的上级目录中生成<code>.buildinfo</code>、<code>.changes</code>、<code>.deb</code>三个文件，如图所示</p>
<p><img src="https://img.1949hacker.cn//20231017171756.png" alt="20231017171756"></p>
]]></content>
      <categories>
        <category>知识库</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Debian</tag>
        <tag>deb</tag>
      </tags>
  </entry>
  <entry>
    <title>成都凤起兰庭保租房密码锁设置教程</title>
    <url>/%E6%88%90%E9%83%BD%E5%87%A4%E8%B5%B7%E5%85%B0%E5%BA%AD%E4%BF%9D%E7%A7%9F%E6%88%BF%E5%AF%86%E7%A0%81%E9%94%81%E8%AE%BE%E7%BD%AE%E6%95%99%E7%A8%8B.html</url>
    <content><![CDATA[<h1 id="成都城投凤起兰庭保租房二期项目密码锁为《和乐门业》的，可以参照本教程尝试自行设置智能门锁"><a href="#成都城投凤起兰庭保租房二期项目密码锁为《和乐门业》的，可以参照本教程尝试自行设置智能门锁" class="headerlink" title="成都城投凤起兰庭保租房二期项目密码锁为《和乐门业》的，可以参照本教程尝试自行设置智能门锁"></a>成都城投凤起兰庭保租房二期项目密码锁为《和乐门业》的，可以参照本教程尝试自行设置智能门锁</h1><span id="more"></span>

<h2 id="以下是智能门锁操作教程"><a href="#以下是智能门锁操作教程" class="headerlink" title="以下是智能门锁操作教程"></a>以下是智能门锁操作教程</h2><h3 id="第一步：恢复出厂设置"><a href="#第一步：恢复出厂设置" class="headerlink" title="第一步：恢复出厂设置"></a>第一步：恢复出厂设置</h3><p>将门锁的后面板向上滑开，找到恢复出厂设置的按钮，如图所示：</p>
<p><img src="https://img.1949hacker.cn/2a7bd93a17a564ef1d2598af3285741.jpg" alt="密码锁重置按钮"></p>
<p><strong>按住</strong>红圈中的按钮不放，门锁会连续发出响声“滴滴滴”，<strong>响声结束后</strong>，<strong>等待几秒</strong>，随后会语音提示”初始化成功“</p>
<p>来到前面板，触摸<strong>密码输入区</strong>，激活面板，然后按住<strong>#</strong>，直到出现较长的提示音”滴——！“，然后会听到菜单播报，菜单功能如下：</p>
<h4 id="主菜单"><a href="#主菜单" class="headerlink" title="主菜单"></a>主菜单</h4><table>
<thead>
<tr>
<th>按键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>管理员设置</td>
</tr>
<tr>
<td>2</td>
<td>用户设置</td>
</tr>
<tr>
<td>其他</td>
<td>略过，用不住，如有需要补充，联系我，后续抽空补全</td>
</tr>
</tbody></table>
<h4 id="子菜单"><a href="#子菜单" class="headerlink" title="子菜单"></a>子菜单</h4><table>
<thead>
<tr>
<th>主菜单</th>
<th>按键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>管理员设置</td>
<td>1</td>
<td>添加管理员</td>
</tr>
<tr>
<td></td>
<td>2</td>
<td>删除管理员</td>
</tr>
<tr>
<td>用户设置</td>
<td>1</td>
<td>添加用户</td>
</tr>
<tr>
<td></td>
<td>2</td>
<td>删除用户</td>
</tr>
</tbody></table>
<h3 id="创建管理员"><a href="#创建管理员" class="headerlink" title="创建管理员"></a>创建管理员</h3><p>紧跟上一步操作，在初始化完成并进入菜单后，先按<strong>1</strong>听到播报“1、创建管理员，2、删除管理员”后，无需等待语音播报完成，只要听到有语音播报就可以继续操作了，接着按<strong>1</strong>，然后输入管理员密码，<strong>8位数字</strong>，输入后按<strong>#</strong>，这个就是确认键的功能，密码需要输入两次，随后会出现<strong>001</strong>的语音，这个是管理员序号，创建管理员时会依次自动从001到009编号。</p>
<p>完成密码设置后，按<strong>*</strong>键返回上一层，是的，<strong>*</strong>是返回，<strong>#</strong>是确认。</p>
<h3 id="创建用户密码、指纹"><a href="#创建用户密码、指纹" class="headerlink" title="创建用户密码、指纹"></a>创建用户密码、指纹</h3><p>在完成创建管理员后，按照上文的操作，此时你已来到主菜单，按<strong>2</strong>即可进入用户菜单，出现语音，继续操作，按<strong>1</strong>创建用户，此时，密码和指纹<strong>二选一</strong>，创建用户密码则如同创建管理员一样，直接输入<strong>8位密码</strong>，按<strong>#</strong>确认，重复一次，然后会播报用户序号（010开始）按<strong>*</strong>返回，创建第二个密码，你仍旧可以再次创建密码用户，当然，如果需要创建指纹用户，则直接用对应手指按指纹感应器，<strong>重复5次</strong>即可完成指纹用户创建。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>密码锁</tag>
      </tags>
  </entry>
  <entry>
    <title>本站上线周报生成器</title>
    <url>/%E6%9C%AC%E7%AB%99%E4%B8%8A%E7%BA%BF%E5%91%A8%E6%8A%A5%E7%94%9F%E6%88%90%E5%99%A8.html</url>
    <content><![CDATA[<p><a href="https://ai.1949hacker.cn/zh">周报生成器地址：https://ai.1949hacker.cn/zh</a></p>
<p>该工具调用的是OpenAI GPT-3.5 API，速度慢是正常的，等等就好，点击生成后下滑页面就能看到内容了。</p>
]]></content>
      <categories>
        <category>实用工具</category>
      </categories>
      <tags>
        <tag>周报生成器</tag>
        <tag>OpenAI</tag>
      </tags>
  </entry>
  <entry>
    <title>本站上线私有apt源仓库及自制实用deb包</title>
    <url>/%E6%9C%AC%E7%AB%99%E4%B8%8A%E7%BA%BF%E7%A7%81%E6%9C%89apt%E6%BA%90%E4%BB%93%E5%BA%93%E5%8F%8A%E8%87%AA%E5%88%B6%E5%AE%9E%E7%94%A8deb%E5%8C%85.html</url>
    <content><![CDATA[<p>本站apt源添加命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;deb [trusted=yes] http://117.176.215.230:20888 ./&quot; &gt;&gt; /etc/apt/sources.list</span><br><span class="line">apt update</span><br></pre></td></tr></table></figure>

<p>以下是工具介绍</p>
<span id="more"></span>

<h2 id="aptdownloader"><a href="#aptdownloader" class="headerlink" title="aptdownloader"></a>aptdownloader</h2><p>如果你用过yumdownloader从yum源下载rpm包，那么看到名字你应该就知道这是一个什么工具了</p>
<p><a href="https://github.com/1949hacker/aptdownloader">github仓库地址:https://github.com/1949hacker/aptdownloader</a></p>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p><code>aptdownloader &lt;package name&gt;</code></p>
<p>该命令会下载指定的包及其依赖到当前目录中，多个包名用空格分隔，示例：</p>
<p><code>aptdownloader docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</code></p>
<p><strong>注意事项：该工具下载的包及其依赖是基于当前系统的，所以你要离线导入deb包的目标系统也必须是相同系统才可！</strong></p>
<h3 id="工具原理"><a href="#工具原理" class="headerlink" title="工具原理"></a>工具原理</h3><p>原命令<code>apt download $(apt-rdepends -p &lt;package name&gt; | grep -v &quot;^ &quot;)</code></p>
<p>使用python sys传参，subprocess执行命令，简化了原命令的操作方式</p>
]]></content>
      <categories>
        <category>资源</category>
      </categories>
      <tags>
        <tag>deb</tag>
        <tag>apt</tag>
        <tag>aptdownloader</tag>
        <tag>apt源</tag>
      </tags>
  </entry>
  <entry>
    <title>硬盘容量为何达不到厂家标称的容量？硬盘容量造假缩水？</title>
    <url>/%E7%A1%AC%E7%9B%98%E5%AE%B9%E9%87%8F%E4%B8%BA%E4%BD%95%E8%BE%BE%E4%B8%8D%E5%88%B0%E5%8E%82%E5%AE%B6%E6%A0%87%E7%A7%B0%E7%9A%84%E5%AE%B9%E9%87%8F%EF%BC%9F%E7%A1%AC%E7%9B%98%E5%AE%B9%E9%87%8F%E9%80%A0%E5%81%87%E7%BC%A9%E6%B0%B4%EF%BC%9F.html</url>
    <content><![CDATA[<p>标注16TB的硬盘为何实际容量只有14.5T左右？硬盘容量造假？缩水？真相是。。。</p>
<span id="more"></span>

<p>因为硬盘厂家对于容量的计算是以1000为单位，而操作系统是以1024为单位，所以硬盘厂家的容量转换为操作系统识别到的容量是会低于硬盘标称的容量，根据容量单位乘除对应的单位次幂，以T为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">T = 1024G = 1024M = 1024K = 1024B</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所以计算的公式应该是</span></span><br><span class="line">容量 * 1000^4 / 1024^4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以16TB硬盘为例</span></span><br><span class="line">16*1000^4/1024^4≈14.55</span><br></pre></td></tr></table></figure>

<p>对于使用磁盘阵列的用户，容量计算方式如下：</p>
<table>
<thead>
<tr>
<th>阵列类型</th>
<th>盘数</th>
<th>容量</th>
<th>阵列特征</th>
</tr>
</thead>
<tbody><tr>
<td>RAID0（条带）</td>
<td>1块及以上</td>
<td>N块</td>
<td>拥有最快的速度和最高的容量，当然，也拥有着最低的安全性，一旦掉盘数据便会丢失</td>
</tr>
<tr>
<td>RAID1（镜像）</td>
<td>2块</td>
<td>一半</td>
<td>拥有1倍的写入速度2倍的读取速度，安全性最高，一块盘故障时还可使用镜像盘继续工作</td>
</tr>
<tr>
<td>RAID5（单重校验）</td>
<td>3块及以上</td>
<td>N-1</td>
<td>性价比最高的阵列方式，读写速度为N-1，也就是3块盘时有两块盘的速度之和，8块盘时有7块盘的速度之和，出现一块故障盘时仍然能正常工作，不丢失数据（建议单个RAID5不要超过8块盘，可将多组RAID5组RAID0也就是RAID50阵列）</td>
</tr>
<tr>
<td>RAID6（双重校验）</td>
<td>4块及以上</td>
<td>N-2</td>
<td>性价比略低于RAID5，读写速度为N-2，可故障两块盘</td>
</tr>
<tr>
<td>RAIDZ3（三重校验，ZFS专属）</td>
<td>5块盘及以上</td>
<td>N-3</td>
<td>略低于RAID6，N-3，可故障3块盘</td>
</tr>
</tbody></table>
<p>在ZFS文件系统中，有以下几种阵列方式：</p>
<table>
<thead>
<tr>
<th>ZFS阵列</th>
<th>RAID阵列</th>
</tr>
</thead>
<tbody><tr>
<td>Strip（条带）</td>
<td>RAID0</td>
</tr>
<tr>
<td>Mirror（镜像）</td>
<td>RAID1</td>
</tr>
<tr>
<td>RAIDZ1</td>
<td>RAID5</td>
</tr>
<tr>
<td>RAIDZ2</td>
<td>RAID6</td>
</tr>
<tr>
<td>RAIDZ3</td>
<td>无</td>
</tr>
</tbody></table>
<p><strong>2024年1月13日补充：考虑到zfs文件系统的特性，减少文件系统日志等占用容量0.5%，减少余量空间分配占用容量2.93%</strong></p>
<p>若您使用的是昱格NAS，在创建存储池时我们会默认为您做容量限制，以防存储池容量被撑爆卡死系统，会将可用容量限制为实际容量的95%</p>
<p>若您采购了昱格的YGENAS-VH5（桌面式5盘位NAS）且配备了5块16TB硬盘，做RAIDZ1阵列并开启默认限额，那您的实际可用容量计算公式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">16*1000^4/1024^4*(5-1)*(1-0.05)=55.2972 TiB</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2024年1月13日更新后计算公式为</span></span><br><span class="line">16*1000^4/1024^4*(5-1)*(1-0.05-0.005-0.0293)=53.3 TiB</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">计算解析</span></span><br><span class="line">16 TB转换为TiB：*1000^4/1024^4</span><br><span class="line">计算RAIDZ1 N-1容量：*(5-1)</span><br><span class="line">计算zfs存储池占用容量：*(1-0.05-0.005-0.0293)</span><br></pre></td></tr></table></figure>

<p>2024.1.13 昱格YGENAS-RH16s高性能全闪NAS配合希捷5U84磁盘扩展柜，建设了百T级U.2高性能SSD+PB级大容量HDD存储池，采用100G光纤链路发布共享，项目金额二百多万</p>
<p>昱格——科技智能服务商</p>
<p>为您提供专业虚拟化、云桌面、NAS存储等建设方案，从服务器、存储到网络全方位覆盖，一站式解决方案提供。</p>
<p>欢迎致电400-028-0061（亦可通过文末WeChat扫描二维码添加微信联系我，请注明来自1949hacker）</p>
]]></content>
      <categories>
        <category>知识库</category>
      </categories>
      <tags>
        <tag>硬盘</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次构建armv8平台vsftpd Docker镜像的过程</title>
    <url>/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%9E%84%E5%BB%BAarmv8%E5%B9%B3%E5%8F%B0vsftpd-Docker%E9%95%9C%E5%83%8F%E7%9A%84%E8%BF%87%E7%A8%8B.html</url>
    <content><![CDATA[<p>因客户使用飞腾2000平台需要部署vsftpd，但因系统环境不同存在诸多部署问题，且无适配的armv8版本vsftpd容器，特此专门构建vsftpd镜像并记录构建过程</p>
<span id="more"></span>

<p>Dockerfile代码如下</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> arm64v8/debian</span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;scepter@1949hacker.cn&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">rm</span> /etc/apt/sources.list.d/debian.sources -f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;deb http://mirrors.ustc.edu.cn/debian/ bookworm main contrib non-free non-free-firmware\</span></span></span><br><span class="line"><span class="string"><span class="language-bash">deb-src http://mirrors.ustc.edu.cn/debian/ bookworm main contrib non-free non-free-firmware\</span></span></span><br><span class="line"><span class="string"><span class="language-bash">deb http://mirrors.ustc.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware\</span></span></span><br><span class="line"><span class="string"><span class="language-bash">deb-src http://mirrors.ustc.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware\</span></span></span><br><span class="line"><span class="string"><span class="language-bash">deb http://mirrors.ustc.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware\</span></span></span><br><span class="line"><span class="string"><span class="language-bash">deb-src http://mirrors.ustc.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware\</span></span></span><br><span class="line"><span class="string"><span class="language-bash">deb http://mirrors.ustc.edu.cn/debian-security/ bookworm-security main contrib non-free non-free-firmware\</span></span></span><br><span class="line"><span class="string"><span class="language-bash">deb-src http://mirrors.ustc.edu.cn/debian-security/ bookworm-security main contrib non-free non-free-firmware&quot;</span> &gt; /etc/apt/sources.list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update -y &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">	apt install -y openssl netcat-openbsd vsftpd --no-install-recommends &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">	apt autoremove -y &amp;&amp; apt clean -y &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">	<span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># VSFTPD configuration</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> vsftpd.conf /etc/vsftpd.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># VSFTPD pre-configurations</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-entrypoint.sh /var/tmp/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /var/tmp/docker-entrypoint.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/var/tmp/docker-entrypoint.sh&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">20</span>/tcp <span class="number">21</span>/tcp</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">4559</span>/tcp <span class="number">4560</span>/tcp <span class="number">4561</span>/tcp <span class="number">4562</span>/tcp <span class="number">4563</span>/tcp <span class="number">4564</span>/tcp</span><br><span class="line"></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> --interval=5m --<span class="built_in">timeout</span>=3s \</span></span><br><span class="line"><span class="language-bash">  CMD nc -z localhost 21 || <span class="built_in">exit</span> 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;vsftpd&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># docker build -t 1949hacker/vsftpd:latest .</span></span><br></pre></td></tr></table></figure>

<p>docker-entrypoint.sh代码如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">set -x</span><br><span class="line"></span><br><span class="line">if [ &quot;$1&quot; = &quot;vsftpd&quot; ]; then</span><br><span class="line">	VSFTPDDIR=&quot;/etc&quot;</span><br><span class="line">	PIDDIR=&quot;/var/run/vsftpd&quot;</span><br><span class="line">	LOGDIR=&quot;/var/log/vsftpd&quot;</span><br><span class="line">	SECURECHROOTDIR=&quot;/var/run/vsftpd/empty&quot;</span><br><span class="line">	PRIVATEKEY_FILE=&quot;/etc/ssl/private/vsftpd.key&quot;</span><br><span class="line">	CERTIFICATE_FILE=&quot;/etc/ssl/certs/vsftpd.crt&quot;</span><br><span class="line">	CSR_FILE=&quot;/etc/ssl/certs/vsftpd.csr&quot;</span><br><span class="line"></span><br><span class="line">	if [ -z &quot;$FTP_SERVER_NAME&quot; ]; then</span><br><span class="line">		export FTP_SERVER_NAME=&quot;Welcome to My FTP service&quot;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [ -z &quot;$FTP_REPOSITORY&quot; ]; then</span><br><span class="line">		export FTP_REPOSITORY=&quot;/srv_volume&quot;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [ -z &quot;$FTP_USER&quot; ]; then</span><br><span class="line">		export FTP_USER=&quot;admin&quot;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [ -z &quot;$FTP_PASSWORD&quot; ]; then</span><br><span class="line">		export FTP_PASSWORD=&quot;$(cat /dev/urandom | tr -dc A-Z-a-z-0-9 | head -c 18)&quot;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [ -z &quot;$PASV_ADDRESS&quot; ]; then</span><br><span class="line">		export PASV_ADDRESS=&quot;$(tail -n 1 /etc/hosts | awk &#x27;&#123;print $1&#125;&#x27;)&quot;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [ -z &quot;$PASV_PROMISCUOUS&quot; ]; then</span><br><span class="line">		export PASV_PROMISCUOUS=&quot;false&quot;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [ -z &quot;$PASV_MIN_PORT&quot; ]; then</span><br><span class="line">		export PASV_MIN_PORT=&quot;4559&quot;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [ -z &quot;$PASV_MAX_PORT&quot; ]; then</span><br><span class="line">		export PASV_MAX_PORT=&quot;4564&quot;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [ -z &quot;$USESSL&quot; ]; then</span><br><span class="line">		export USESSL=&quot;false&quot;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [ -z &quot;$FORCESSL&quot; ]; then</span><br><span class="line">		export FORCESSL=&quot;false&quot;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	EXIST=1</span><br><span class="line">	grep -qw ^&quot;$FTP_USER&quot; /etc/passwd || EXIST=0</span><br><span class="line"></span><br><span class="line">	if [ &quot;$EXIST&quot; -eq 0 ]; then</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">Neccesary directories creation</span></span><br><span class="line">		mkdir -p &quot;$LOGDIR&quot; &quot;$PIDDIR&quot; &quot;$SECURECHROOTDIR&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">VSFTPd <span class="built_in">log</span> file creation</span></span><br><span class="line">		touch &quot;$&#123;LOGDIR&#125;&quot;/vsftpd.log</span><br><span class="line">		touch &quot;$&#123;LOGDIR&#125;&quot;/xferlog.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">User creation / configuration</span></span><br><span class="line">		useradd -c &quot;User for send files using vSFTPD&quot; -d &quot;$FTP_REPOSITORY&quot; -m &quot;$FTP_USER&quot; &amp;&gt; /dev/null &amp;&amp; echo &quot;FTP user creation [ OK ]&quot; || exit 2</span><br><span class="line">		chown &quot;$FTP_USER&quot;. &quot;$FTP_REPOSITORY&quot; &amp;&gt; /dev/null &amp;&amp; echo &quot;FTP user directory configuration [ OK ]&quot; || exit 2</span><br><span class="line">		echo -e &quot;$FTP_PASSWORD\\n$FTP_PASSWORD&quot; | passwd &quot;$FTP_USER&quot; &amp;&gt; /dev/null &amp;&amp; echo &quot;FTP user password configuration [ OK ]&quot; || exit 2</span><br><span class="line"></span><br><span class="line">		sed -i &quot;s/PASV_ADDRESS_CUSTOM/$PASV_ADDRESS/g&quot; &quot;$&#123;VSFTPDDIR&#125;/vsftpd.conf&quot;</span><br><span class="line">		sed -i &quot;s/FTP_SERVER_NAME_CUSTOM/$FTP_SERVER_NAME/g&quot; &quot;$&#123;VSFTPDDIR&#125;/vsftpd.conf&quot;</span><br><span class="line"></span><br><span class="line">		if [ &quot;$PASV_PROMISCUOUS&quot; == &quot;true&quot; ]; then</span><br><span class="line">			echo &quot;pasv_promiscuous=YES&quot; &gt;&gt; &quot;$&#123;VSFTPDDIR&#125;/vsftpd.conf&quot;</span><br><span class="line">		fi</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			echo &quot;pasv_min_port=$PASV_MIN_PORT&quot;</span><br><span class="line">			echo &quot;pasv_max_port=$PASV_MAX_PORT&quot;</span><br><span class="line">		&#125; &gt;&gt; &quot;$&#123;VSFTPDDIR&#125;/vsftpd.conf&quot;</span><br><span class="line"></span><br><span class="line">		if [ &quot;$USESSL&quot; == &quot;true&quot; ]; then</span><br><span class="line">			&#123;</span><br><span class="line">				echo &quot;ssl_enable=YES&quot;</span><br><span class="line">				echo &quot;allow_anon_ssl=NO&quot;</span><br><span class="line">				echo &quot;ssl_tlsv1=NO&quot;</span><br><span class="line">				echo &quot;ssl_sslv2=NO&quot;</span><br><span class="line">				echo &quot;ssl_sslv3=NO&quot;</span><br><span class="line">				echo &quot;rsa_cert_file=$CERTIFICATE_FILE&quot;</span><br><span class="line">				echo &quot;rsa_private_key_file=$PRIVATEKEY_FILE&quot;</span><br><span class="line">			&#125; &gt;&gt; &quot;$&#123;VSFTPDDIR&#125;/vsftpd.conf&quot;</span><br><span class="line"></span><br><span class="line">			if [ -z &quot;$SSL_CERTIFICATE&quot; ]; then</span><br><span class="line">				openssl genrsa -out &quot;$PRIVATEKEY_FILE&quot; 4096 &amp;&gt; /dev/null &amp;&amp; echo &quot;Private key generate [ OK ]&quot; || exit 2</span><br><span class="line">				openssl req -subj &quot;/CN=$HOSTNAME/C=ES/ST=Catalunya/L=Barcelona/O=Arroyof Solutions/OU=Sistemas/emailAddress=enzo@arroyof.com&quot; -sha256 -new -key &quot;$PRIVATEKEY_FILE&quot; -out &quot;$CSR_FILE&quot; &amp;&gt; /dev/null &amp;&amp; echo &quot;CSR generate [ OK ]&quot; || exit 2</span><br><span class="line">				openssl x509 -req -days 365 -in &quot;$CSR_FILE&quot; -signkey &quot;$PRIVATEKEY_FILE&quot; -sha256 -out &quot;$CERTIFICATE_FILE&quot; &amp;&gt; /dev/null &amp;&amp; echo &quot;Self-signed certificate generate [ OK ]&quot; || exit 2</span><br><span class="line">			fi</span><br><span class="line">		fi</span><br><span class="line"></span><br><span class="line">		if [ &quot;$FORCESSL&quot; == &quot;false&quot; ]; then</span><br><span class="line">			&#123;</span><br><span class="line">				echo &quot;force_local_logins_ssl=NO&quot;</span><br><span class="line">				echo &quot;force_local_data_ssl=NO&quot;</span><br><span class="line">			&#125; &gt;&gt; &quot;$&#123;VSFTPDDIR&#125;/vsftpd.conf&quot;</span><br><span class="line">		fi</span><br><span class="line"></span><br><span class="line">		touch &quot;$&#123;VSFTPDDIR&#125;/vsftpd.user_list&quot;</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">VSFTPd standard <span class="built_in">log</span> container redirection</span></span><br><span class="line">	tail -f &quot;$&#123;LOGDIR&#125;&quot;/vsftpd.log | tee /dev/stdout &amp;</span><br><span class="line">	tail -f &quot;$&#123;LOGDIR&#125;&quot;/xferlog.log | tee /dev/stdout &amp;</span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOB</span><br><span class="line"></span><br><span class="line">****************************************************</span><br><span class="line">*                                                  *</span><br><span class="line">*    Docker image: oscarenzo/vsftpd                *</span><br><span class="line">*    https://gitlab.com/docker-files1/vsftpd       *</span><br><span class="line">*                                                  *</span><br><span class="line">****************************************************</span><br><span class="line"></span><br><span class="line">SERVER SETTINGS</span><br><span class="line">---------------</span><br><span class="line">· FTP host: $PASV_ADDRESS</span><br><span class="line">· FTP user: $FTP_USER</span><br><span class="line">· FTP password: $FTP_PASSWORD</span><br><span class="line">· PATH: $FTP_REPOSITORY</span><br><span class="line">· Promiscuous: $PASV_PROMISCUOUS</span><br><span class="line">· SSL enabled: $USESSL</span><br><span class="line">· SSL forced: $FORCESSL</span><br><span class="line">---------------</span><br><span class="line"></span><br><span class="line">EOB</span><br><span class="line"></span><br><span class="line">&quot;$@&quot; &quot;$&#123;VSFTPDDIR&#125;/vsftpd.conf&quot; &amp;</span><br><span class="line">pid=&quot;$&#123;!&#125;&quot;</span><br><span class="line">wait &quot;$&#123;pid&#125;&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>vsftpd.conf配置文件如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Run <span class="keyword">in</span> the foreground to keep the container running:</span></span><br><span class="line">background=NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Allow anonymous FTP? (Beware - allowed by default <span class="keyword">if</span> you comment this out).</span></span><br><span class="line">anonymous_enable=NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Uncomment this to allow <span class="built_in">local</span> <span class="built_in">users</span> to <span class="built_in">log</span> <span class="keyword">in</span>.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">When SELinux is enforcing check <span class="keyword">for</span> SE bool ftp_home_dir</span></span><br><span class="line">local_enable=YES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Uncomment this to <span class="built_in">enable</span> any form of FTP write <span class="built_in">command</span>.</span></span><br><span class="line">write_enable=YES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Default <span class="built_in">umask</span> <span class="keyword">for</span> <span class="built_in">local</span> <span class="built_in">users</span> is 077. You may wish to change this to 022,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">if</span> your <span class="built_in">users</span> expect that (022 is used by most other ftpd<span class="string">&#x27;s)</span></span></span><br><span class="line">local_umask=022</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Uncomment this to allow the anonymous FTP user to upload files. This only</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">has an effect if the above global write enable is activated. Also, you will</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">obviously need to create a directory writable by the FTP user.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">When SELinux is enforcing check for SE bool allow_ftpd_anon_write, allow_ftpd_full_access</span></span></span><br><span class="line">anon_upload_enable=NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Uncomment this if you want the anonymous FTP user to be able to create</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">new directories.</span></span></span><br><span class="line">anon_mkdir_write_enable=NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Activate directory messages - messages given to remote users when they</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">go into a certain directory.</span></span></span><br><span class="line">dirmessage_enable=YES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Activate logging of uploads/downloads.</span></span></span><br><span class="line">xferlog_enable=YES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Make sure PORT transfer connections originate from port 20 (ftp-data).</span></span></span><br><span class="line">connect_from_port_20=YES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">If you want, you can arrange for uploaded anonymous files to be owned by</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">a different user. Note! Using &quot;root&quot; for uploaded files is not</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">recommended!</span></span></span><br><span class="line">chown_uploads=NO</span><br><span class="line">chown_username=root</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">This option is the name of the file to which we write the vsftpd style log file.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">This log is only written if the option xferlog_enable is set, and xferlog_std_format is NOT set.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Alternatively, it is written if you have set the option dual_log_enable.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">One further complication - if you have set syslog_enable, then this file is not written and output is sent to the system log instead.</span></span></span><br><span class="line">vsftpd_log_file=/var/log/vsftpd/vsftpd.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">This option is the name of the file to which we write the wu-ftpd style transfer log.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">The transfer log is only written if the option xferlog_enable is set, along with xferlog_std_format.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Alternatively, it is written if you have set the option dual_log_enable.</span></span></span><br><span class="line">xferlog_file=/var/log/vsftpd/xferlog.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">If you want, you can have your log file in standard ftpd xferlog format.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Note that the default log file location is /var/log/xferlog in this case.</span></span></span><br><span class="line">xferlog_std_format=YES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">You may change the default value for timing out an idle session.</span></span></span><br><span class="line">idle_session_timeout=600</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">You may change the default value for timing out a data connection.</span></span></span><br><span class="line">data_connection_timeout=300</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">It is recommended that you define on your system a unique user which the</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">ftp server can use as a totally isolated and unprivileged user.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">nopriv_user=ftpsecure</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Enable this and the server will recognise asynchronous ABOR requests. Not</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">recommended for security (the code is non-trivial). Not enabling it,</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">however, may confuse older FTP clients.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">async_abor_enable=YES</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">By default the server will pretend to allow ASCII mode but in fact ignore</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">the request. Turn on the below options to have the server actually do ASCII</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">mangling on files when in ASCII mode. The vsftpd.conf(5) man page explains</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">the behaviour when these options are disabled.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Beware that on some FTP servers, ASCII support allows a denial of service</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">attack (DoS) via the command &quot;SIZE /big/file&quot; in ASCII mode. vsftpd</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">predicted this attack and has always been safe, reporting the size of the</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">raw file.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">ASCII mangling is a horrible feature of the protocol.</span></span></span><br><span class="line">ascii_upload_enable=NO</span><br><span class="line">ascii_download_enable=NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">You may specify a file of disallowed anonymous e-mail addresses. Apparently</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">useful for combatting certain DoS attacks.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">deny_email_enable=YES</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">(default follows)</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">banned_email_file=/etc/vsftpd/banned_emails</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">You may specify an explicit list of local users to chroot() to their home</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">directory. If chroot_local_user is YES, then this list becomes a list of</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">users to NOT chroot().</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">(Warning! chroot&#x27;</span>ing can be very dangerous. If using <span class="built_in">chroot</span>, make sure that</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the user does not have write access to the top level directory within the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">chroot</span>)</span></span><br><span class="line">chroot_local_user=YES</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">chroot_list_enable=YES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(default follows)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">chroot_list_file=/etc/vsftpd/chroot_list</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Allow <span class="built_in">chroot</span> writeable</span></span><br><span class="line">allow_writeable_chroot=YES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This option should be the name of a directory <span class="built_in">which</span> is empty.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Also, the directory should not be writable by the ftp user.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This directory is used as a secure <span class="built_in">chroot</span>() jail at <span class="built_in">times</span> vsftpd does not require filesystem access.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Default: /usr/share/empty</span></span><br><span class="line">secure_chroot_dir=/var/run/vsftpd/empty</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You may activate the <span class="string">&quot;-R&quot;</span> option to the <span class="built_in">builtin</span> <span class="built_in">ls</span>. This is disabled by</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">default to avoid remote <span class="built_in">users</span> being able to cause excessive I/O on large</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sites. However, some broken FTP clients such as <span class="string">&quot;ncftp&quot;</span> and <span class="string">&quot;mirror&quot;</span> assume</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the presence of the <span class="string">&quot;-R&quot;</span> option, so there is a strong <span class="keyword">case</span> <span class="keyword">for</span> enabling it.</span></span><br><span class="line">ls_recurse_enable=NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">When <span class="string">&quot;listen&quot;</span> directive is enabled, vsftpd runs <span class="keyword">in</span> standalone mode and</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">listens on IPv4 sockets. This directive cannot be used <span class="keyword">in</span> conjunction</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">with the listen_ipv6 directive.</span></span><br><span class="line">listen=YES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This directive enables listening on IPv6 sockets. By default, listening</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">on the IPv6 <span class="string">&quot;any&quot;</span> address (::) will accept connections from both IPv6</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and IPv4 clients. It is not necessary to listen on *both* IPv4 and IPv6</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sockets. If you want that (perhaps because you want to listen on specific</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">addresses) <span class="keyword">then</span> you must run two copies of vsftpd with two configuration</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">files.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Make sure, that one of the listen options is commented !!</span></span><br><span class="line">listen_ipv6=NO</span><br><span class="line"></span><br><span class="line">pam_service_name=vsftpd</span><br><span class="line">userlist_enable=YES</span><br><span class="line">tcp_wrappers=YES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Logging</span></span><br><span class="line">log_ftp_protocol=YES</span><br><span class="line">syslog_enable=NO</span><br><span class="line">dual_log_enable=YES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Variables <span class="built_in">set</span> at container runtime</span></span><br><span class="line">ftpd_banner=FTP_SERVER_NAME_CUSTOM</span><br><span class="line">pasv_address=PASV_ADDRESS_CUSTOM</span><br><span class="line">pasv_addr_resolve=NO</span><br><span class="line">pasv_enable=YES</span><br></pre></td></tr></table></figure>

<p>将以上三个文件放到同一目录中，使用<code>docker build -t 1949hacker/vsftpd:latest .</code>构建即可。</p>
<p>git仓库地址：<a href="https://github.com/1949hacker/vsftpd">https://github.com/1949hacker/vsftpd</a></p>
]]></content>
      <categories>
        <category>知识库</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>armv8</tag>
        <tag>vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title>记录初学Python开发fio测试工具</title>
    <url>/%E8%AE%B0%E5%BD%95%E5%88%9D%E5%AD%A6Python%E5%BC%80%E5%8F%91fio%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7.html</url>
    <content><![CDATA[<h1 id="使用Python自动测试IOPS性能并格式化输出"><a href="#使用Python自动测试IOPS性能并格式化输出" class="headerlink" title="使用Python自动测试IOPS性能并格式化输出"></a>使用Python自动测试IOPS性能并格式化输出</h1><blockquote>
<p>代码过多,请点击<strong>阅读全文</strong>查看</p>
</blockquote>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">TODO:</span></span><br><span class="line"><span class="string">    此脚本已测试兼容环境为Debian 11.6</span></span><br><span class="line"><span class="string">    此脚本的测试路径为&quot;/iopsTest&quot;,请提前将你要测试的设备挂载到&quot;/iopsTest&quot;</span></span><br><span class="line"><span class="string">    注意自行根据盘位修改下列numjobs参数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess, re, os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机写</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">randwrite</span>():</span><br><span class="line">    <span class="comment"># 初始化用于存储运行结果的列表</span></span><br><span class="line">    bw = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    iops = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># fio重复运行4次</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;随机写进行中...&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        cmd = [</span><br><span class="line">            <span class="string">&quot;fio&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-name=YEOS&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-size=32G&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-runtime=60s&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-time_base&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-bs=4k&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-direct=1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-rw=randwrite&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-ioengine=libaio&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-numjobs=8&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-group_reporting&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-iodepth=64&quot;</span>,</span><br><span class="line">            <span class="string">f&quot;-filename=/iopsTest/<span class="subst">&#123;i&#125;</span>&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-randrepeat=0&quot;</span>,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将fio运行结果标准输出到管道</span></span><br><span class="line">        fio1 = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=<span class="literal">False</span>)</span><br><span class="line">        fio2 = subprocess.Popen(</span><br><span class="line">            [<span class="string">&quot;grep&quot;</span>, <span class="string">&quot;samples&quot;</span>], stdin=fio1.stdout, stdout=subprocess.PIPE, shell=<span class="literal">False</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用communicate获取子进程的标准输出并格式化为utf-8编码</span></span><br><span class="line">        fio = fio2.communicate()[<span class="number">0</span>].decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化列表</span></span><br><span class="line">        bw_num = []</span><br><span class="line">        iops_num = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 匹配数字和小数点，并将其元素更新</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fio.split(<span class="string">&quot;\n&quot;</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;bw&quot;</span> <span class="keyword">in</span> line:</span><br><span class="line">                bw_num.extend(re.findall(<span class="string">r&quot;\d+\.\d+|\d+&quot;</span>, line))</span><br><span class="line">            <span class="keyword">elif</span> <span class="string">&quot;iops&quot;</span> <span class="keyword">in</span> line:</span><br><span class="line">                iops_num.extend(re.findall(<span class="string">r&quot;\d+\.\d+|\d+&quot;</span>, line))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将str类型转换为float后再转换为int</span></span><br><span class="line">        bw_num = [<span class="built_in">int</span>(<span class="built_in">float</span>(e)) <span class="keyword">for</span> e <span class="keyword">in</span> bw_num]</span><br><span class="line">        iops_num = [<span class="built_in">int</span>(<span class="built_in">float</span>(e)) <span class="keyword">for</span> e <span class="keyword">in</span> iops_num]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;单次带宽运行结果:<span class="subst">&#123;bw_num&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;单次IOPS运行结果:<span class="subst">&#123;iops_num&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 跳过第一次运行结果</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 格式化fio结果</span></span><br><span class="line">            <span class="keyword">for</span> KorM <span class="keyword">in</span> fio.split(<span class="string">&quot;\n&quot;</span>):</span><br><span class="line">                <span class="comment"># 判断格式化的结果中是否存在MiB单位的值</span></span><br><span class="line">                <span class="keyword">if</span> <span class="string">&quot;MiB&quot;</span> <span class="keyword">in</span> KorM:</span><br><span class="line">                    <span class="comment"># 若有则转换为KiB</span></span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;输出结果为MiB单位,将进行转换&quot;</span>)</span><br><span class="line">                    bw[<span class="number">0</span>] += bw_num[<span class="number">0</span>] * <span class="number">1024</span></span><br><span class="line">                    bw[<span class="number">1</span>] += bw_num[<span class="number">1</span>] * <span class="number">1024</span></span><br><span class="line">                    bw[<span class="number">2</span>] += bw_num[<span class="number">3</span>] * <span class="number">1024</span></span><br><span class="line">                    iops[<span class="number">0</span>] += iops_num[<span class="number">0</span>]</span><br><span class="line">                    iops[<span class="number">1</span>] += iops_num[<span class="number">1</span>]</span><br><span class="line">                    iops[<span class="number">2</span>] += iops_num[<span class="number">2</span>]</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;带宽第<span class="subst">&#123;i&#125;</span>次值:<span class="subst">&#123;bw&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;IOPS第<span class="subst">&#123;i&#125;</span>次值:<span class="subst">&#123;iops&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">elif</span> <span class="string">&quot;KiB&quot;</span> <span class="keyword">in</span> KorM:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;输出结果为KiB单位,不转换&quot;</span>)</span><br><span class="line">                    bw[<span class="number">0</span>] += bw_num[<span class="number">0</span>]</span><br><span class="line">                    bw[<span class="number">1</span>] += bw_num[<span class="number">1</span>]</span><br><span class="line">                    bw[<span class="number">2</span>] += bw_num[<span class="number">3</span>]</span><br><span class="line">                    iops[<span class="number">0</span>] += iops_num[<span class="number">0</span>]</span><br><span class="line">                    iops[<span class="number">1</span>] += iops_num[<span class="number">1</span>]</span><br><span class="line">                    iops[<span class="number">2</span>] += iops_num[<span class="number">2</span>]</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;带宽第<span class="subst">&#123;i&#125;</span>次值:<span class="subst">&#123;bw&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;IOPS第<span class="subst">&#123;i&#125;</span>次值:<span class="subst">&#123;iops&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    bwMin = <span class="built_in">int</span>(bw[<span class="number">0</span>] / <span class="number">3</span>)</span><br><span class="line">    bwMax = <span class="built_in">int</span>(bw[<span class="number">1</span>] / <span class="number">3</span>)</span><br><span class="line">    bwAvg = <span class="built_in">int</span>(bw[<span class="number">2</span>] / <span class="number">3</span>)</span><br><span class="line">    iopsMin = <span class="built_in">int</span>(iops[<span class="number">0</span>] / <span class="number">3</span>)</span><br><span class="line">    iopsMax = <span class="built_in">int</span>(iops[<span class="number">1</span>] / <span class="number">3</span>)</span><br><span class="line">    iopsAvg = <span class="built_in">int</span>(iops[<span class="number">2</span>] / <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">f&quot;\n\n\n随机写均值如下:\n带宽最小值:<span class="subst">&#123;bwMin&#125;</span>,最大值<span class="subst">&#123;bwMax&#125;</span>,均值<span class="subst">&#123;bwAvg&#125;</span>\nIOPS最小值:<span class="subst">&#123;iopsMin&#125;</span>,&quot;</span></span><br><span class="line">        <span class="string">f&quot;最大值<span class="subst">&#123;iopsMax&#125;</span>,均值<span class="subst">&#123;iopsAvg&#125;</span>&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建读文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_readFile</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;初始化读测试环境,至少需要十几分钟甚至几十分钟,等着...&quot;</span>)</span><br><span class="line">    clear = subprocess.Popen([<span class="string">&quot;rm&quot;</span>, <span class="string">&quot;-rf&quot;</span>, <span class="string">&quot;/iopsTest/*&quot;</span>], shell=<span class="literal">False</span>)</span><br><span class="line">    clear.wait()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;环境检测完成,创建读测试文件...&quot;</span>)</span><br><span class="line">    cmd = [</span><br><span class="line">        <span class="string">&quot;fio&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-name=create_read&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-size=32G&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-bs=1M&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-direct=1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-rw=write&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-ioengine=libaio&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-numjobs=8&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-filename=/iopsTest/read&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line">    create = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=<span class="literal">False</span>)</span><br><span class="line">    done = create.communicate()[<span class="number">0</span>].decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机读</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">randread</span>():</span><br><span class="line">    <span class="comment"># 初始化用于存储运行结果的列表</span></span><br><span class="line">    bw = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    iops = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="comment"># fio重复运行4次</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;随机读进行中...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        cmd = [</span><br><span class="line">            <span class="string">&quot;fio&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-name=YEOS&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-size=32G&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-runtime=60s&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-time_base&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-bs=4k&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-direct=1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-rw=randwrite&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-ioengine=libaio&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-numjobs=8&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-group_reporting&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-iodepth=64&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-filename=/iopsTest/read&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-randrepeat=0&quot;</span>,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将fio运行结果标准输出到管道</span></span><br><span class="line">        fio1 = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=<span class="literal">False</span>)</span><br><span class="line">        fio2 = subprocess.Popen(</span><br><span class="line">            [<span class="string">&quot;grep&quot;</span>, <span class="string">&quot;samples&quot;</span>], stdin=fio1.stdout, stdout=subprocess.PIPE, shell=<span class="literal">False</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用communicate获取子进程的标准输出并格式化为utf-8编码</span></span><br><span class="line">        fio = fio2.communicate()[<span class="number">0</span>].decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化列表</span></span><br><span class="line">        bw_num = []</span><br><span class="line">        iops_num = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 匹配数字和小数点，并将其元素更新</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fio.split(<span class="string">&quot;\n&quot;</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;bw&quot;</span> <span class="keyword">in</span> line:</span><br><span class="line">                bw_num.extend(re.findall(<span class="string">r&quot;\d+\.\d+|\d+&quot;</span>, line))</span><br><span class="line">            <span class="keyword">elif</span> <span class="string">&quot;iops&quot;</span> <span class="keyword">in</span> line:</span><br><span class="line">                iops_num.extend(re.findall(<span class="string">r&quot;\d+\.\d+|\d+&quot;</span>, line))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将str类型转换为float后再转换为int</span></span><br><span class="line">        bw_num = [<span class="built_in">int</span>(<span class="built_in">float</span>(e)) <span class="keyword">for</span> e <span class="keyword">in</span> bw_num]</span><br><span class="line">        iops_num = [<span class="built_in">int</span>(<span class="built_in">float</span>(e)) <span class="keyword">for</span> e <span class="keyword">in</span> iops_num]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;单次带宽运行结果:<span class="subst">&#123;bw_num&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;单次IOPS运行结果:<span class="subst">&#123;iops_num&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 跳过第一次运行结果</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 格式化fio结果</span></span><br><span class="line">            <span class="keyword">for</span> KorM <span class="keyword">in</span> fio.split(<span class="string">&quot;\n&quot;</span>):</span><br><span class="line">                <span class="comment"># 判断格式化的结果中是否存在MiB单位的值</span></span><br><span class="line">                <span class="keyword">if</span> <span class="string">&quot;MiB&quot;</span> <span class="keyword">in</span> KorM:</span><br><span class="line">                    <span class="comment"># 若有则转换为KiB</span></span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;输出结果为MiB单位,将进行转换&quot;</span>)</span><br><span class="line">                    bw[<span class="number">0</span>] += bw_num[<span class="number">0</span>] * <span class="number">1024</span></span><br><span class="line">                    bw[<span class="number">1</span>] += bw_num[<span class="number">1</span>] * <span class="number">1024</span></span><br><span class="line">                    bw[<span class="number">2</span>] += bw_num[<span class="number">3</span>] * <span class="number">1024</span></span><br><span class="line">                    iops[<span class="number">0</span>] += iops_num[<span class="number">0</span>]</span><br><span class="line">                    iops[<span class="number">1</span>] += iops_num[<span class="number">1</span>]</span><br><span class="line">                    iops[<span class="number">2</span>] += iops_num[<span class="number">2</span>]</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;带宽第<span class="subst">&#123;i&#125;</span>次值:<span class="subst">&#123;bw&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;IOPS第<span class="subst">&#123;i&#125;</span>次值:<span class="subst">&#123;iops&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">elif</span> <span class="string">&quot;KiB&quot;</span> <span class="keyword">in</span> KorM:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;输出结果为KiB单位,不转换&quot;</span>)</span><br><span class="line">                    bw[<span class="number">0</span>] += bw_num[<span class="number">0</span>]</span><br><span class="line">                    bw[<span class="number">1</span>] += bw_num[<span class="number">1</span>]</span><br><span class="line">                    bw[<span class="number">2</span>] += bw_num[<span class="number">3</span>]</span><br><span class="line">                    iops[<span class="number">0</span>] += iops_num[<span class="number">0</span>]</span><br><span class="line">                    iops[<span class="number">1</span>] += iops_num[<span class="number">1</span>]</span><br><span class="line">                    iops[<span class="number">2</span>] += iops_num[<span class="number">2</span>]</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;带宽第<span class="subst">&#123;i&#125;</span>次值:<span class="subst">&#123;bw&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;IOPS第<span class="subst">&#123;i&#125;</span>次值:<span class="subst">&#123;iops&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    bwMin = <span class="built_in">int</span>(bw[<span class="number">0</span>] / <span class="number">3</span>)</span><br><span class="line">    bwMax = <span class="built_in">int</span>(bw[<span class="number">1</span>] / <span class="number">3</span>)</span><br><span class="line">    bwAvg = <span class="built_in">int</span>(bw[<span class="number">2</span>] / <span class="number">3</span>)</span><br><span class="line">    iopsMin = <span class="built_in">int</span>(iops[<span class="number">0</span>] / <span class="number">3</span>)</span><br><span class="line">    iopsMax = <span class="built_in">int</span>(iops[<span class="number">1</span>] / <span class="number">3</span>)</span><br><span class="line">    iopsAvg = <span class="built_in">int</span>(iops[<span class="number">2</span>] / <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">f&quot;\n\n\n随机读均值如下:\n带宽最小值:<span class="subst">&#123;bwMin&#125;</span>,最大值<span class="subst">&#123;bwMax&#125;</span>,均值<span class="subst">&#123;bwAvg&#125;</span>\nIOPS最小值:<span class="subst">&#123;iopsMin&#125;</span>,&quot;</span></span><br><span class="line">        <span class="string">f&quot;最大值<span class="subst">&#123;iopsMax&#125;</span>,均值<span class="subst">&#123;iopsAvg&#125;</span>&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机读写</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">randrw</span>():</span><br><span class="line">    <span class="comment"># 初始化用于存储运行结果的列表</span></span><br><span class="line">    bw = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    iops = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="comment"># fio重复运行4次</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;随机读写进行中...&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        cmd = [</span><br><span class="line">            <span class="string">&quot;fio&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-name=YEOS&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-size=32G&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-runtime=60s&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-time_base&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-bs=4k&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-direct=1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-rw=randrw&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-ioengine=libaio&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-numjobs=8&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-group_reporting&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-iodepth=64&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-filename=/iopsTest/read&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-rwmixwrite=30&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-randrepeat=0&quot;</span>,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将fio运行结果标准输出到管道</span></span><br><span class="line">        fio1 = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        fio2 = subprocess.Popen(</span><br><span class="line">            [<span class="string">&quot;grep&quot;</span>, <span class="string">&quot;samples&quot;</span>], stdin=fio1.stdout, stdout=subprocess.PIPE, shell=<span class="literal">False</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用communicate获取子进程的标准输出并格式化为utf-8编码</span></span><br><span class="line">        fio = fio2.communicate()[<span class="number">0</span>].decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化列表</span></span><br><span class="line">        bw_num = []</span><br><span class="line">        iops_num = []</span><br><span class="line">        <span class="comment"># 匹配数字和小数点，并将其元素更新</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fio.split(<span class="string">&quot;\n&quot;</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;bw&quot;</span> <span class="keyword">in</span> line:</span><br><span class="line">                bw_num.extend(re.findall(<span class="string">r&quot;\d+\.\d+|\d+&quot;</span>, line))</span><br><span class="line">            <span class="keyword">elif</span> <span class="string">&quot;iops&quot;</span> <span class="keyword">in</span> line:</span><br><span class="line">                iops_num.extend(re.findall(<span class="string">r&quot;\d+\.\d+|\d+&quot;</span>, line))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将str类型转换为float后再转换为int</span></span><br><span class="line">        bw_num = [<span class="built_in">int</span>(<span class="built_in">float</span>(e)) <span class="keyword">for</span> e <span class="keyword">in</span> bw_num]</span><br><span class="line">        iops_num = [<span class="built_in">int</span>(<span class="built_in">float</span>(e)) <span class="keyword">for</span> e <span class="keyword">in</span> iops_num]</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;单次带宽运行结果:<span class="subst">&#123;bw_num&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;单次IOPS运行结果:<span class="subst">&#123;iops_num&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># 跳过第一次运行结果</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 格式化fio结果</span></span><br><span class="line">            <span class="keyword">for</span> KorM <span class="keyword">in</span> fio.split(<span class="string">&quot;\n&quot;</span>):</span><br><span class="line">                <span class="comment"># 判断格式化的结果中是否存在MiB单位的值</span></span><br><span class="line">                <span class="keyword">if</span> <span class="string">&quot;MiB&quot;</span> <span class="keyword">in</span> KorM:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;输出结果为MiB单位,将进行转换&quot;</span>)</span><br><span class="line">                    <span class="comment"># 若有则转换为KiB</span></span><br><span class="line">                    <span class="comment"># 读带宽</span></span><br><span class="line">                    bw[<span class="number">0</span>] += bw_num[<span class="number">0</span>] * <span class="number">1024</span></span><br><span class="line">                    bw[<span class="number">1</span>] += bw_num[<span class="number">1</span>] * <span class="number">1024</span></span><br><span class="line">                    bw[<span class="number">2</span>] += bw_num[<span class="number">3</span>] * <span class="number">1024</span></span><br><span class="line">                    <span class="comment"># 写带宽</span></span><br><span class="line">                    bw[<span class="number">3</span>] += bw_num[<span class="number">6</span>] * <span class="number">1024</span></span><br><span class="line">                    bw[<span class="number">4</span>] += bw_num[<span class="number">7</span>] * <span class="number">1024</span></span><br><span class="line">                    bw[<span class="number">5</span>] += bw_num[<span class="number">9</span>] * <span class="number">1024</span></span><br><span class="line">                    <span class="comment"># 读IOPS</span></span><br><span class="line">                    iops[<span class="number">0</span>] += iops_num[<span class="number">0</span>]</span><br><span class="line">                    iops[<span class="number">1</span>] += iops_num[<span class="number">1</span>]</span><br><span class="line">                    iops[<span class="number">2</span>] += iops_num[<span class="number">2</span>]</span><br><span class="line">                    <span class="comment"># 写IOPS</span></span><br><span class="line">                    iops[<span class="number">3</span>] += iops_num[<span class="number">5</span>]</span><br><span class="line">                    iops[<span class="number">4</span>] += iops_num[<span class="number">6</span>]</span><br><span class="line">                    iops[<span class="number">5</span>] += iops_num[<span class="number">7</span>]</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;带宽第<span class="subst">&#123;i&#125;</span>次值:<span class="subst">&#123;bw&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;IOPS第<span class="subst">&#123;i&#125;</span>次值:<span class="subst">&#123;iops&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="comment"># 因fio结果存在读写两行，避免重复执行，所以直接跳过后续循环</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="string">&quot;KiB&quot;</span> <span class="keyword">in</span> KorM:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;输出结果为KiB单位,不转换&quot;</span>)</span><br><span class="line">                    <span class="comment"># 读带宽</span></span><br><span class="line">                    bw[<span class="number">0</span>] += bw_num[<span class="number">0</span>]</span><br><span class="line">                    bw[<span class="number">1</span>] += bw_num[<span class="number">1</span>]</span><br><span class="line">                    bw[<span class="number">2</span>] += bw_num[<span class="number">3</span>]</span><br><span class="line">                    <span class="comment"># 写带宽</span></span><br><span class="line">                    bw[<span class="number">3</span>] += bw_num[<span class="number">6</span>]</span><br><span class="line">                    bw[<span class="number">4</span>] += bw_num[<span class="number">7</span>]</span><br><span class="line">                    bw[<span class="number">5</span>] += bw_num[<span class="number">9</span>]</span><br><span class="line">                    <span class="comment"># 读IOPS</span></span><br><span class="line">                    iops[<span class="number">0</span>] += iops_num[<span class="number">0</span>]</span><br><span class="line">                    iops[<span class="number">1</span>] += iops_num[<span class="number">1</span>]</span><br><span class="line">                    iops[<span class="number">2</span>] += iops_num[<span class="number">2</span>]</span><br><span class="line">                    <span class="comment"># 写IOPS</span></span><br><span class="line">                    iops[<span class="number">3</span>] += iops_num[<span class="number">5</span>]</span><br><span class="line">                    iops[<span class="number">4</span>] += iops_num[<span class="number">6</span>]</span><br><span class="line">                    iops[<span class="number">5</span>] += iops_num[<span class="number">7</span>]</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;带宽第<span class="subst">&#123;i&#125;</span>次值:<span class="subst">&#123;bw&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;IOPS第<span class="subst">&#123;i&#125;</span>次值:<span class="subst">&#123;iops&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="comment"># 因fio结果存在读写两行，避免重复执行，所以直接跳过后续循环</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    RbwMin = <span class="built_in">int</span>(bw[<span class="number">0</span>] / <span class="number">3</span>)</span><br><span class="line">    RbwMax = <span class="built_in">int</span>(bw[<span class="number">1</span>] / <span class="number">3</span>)</span><br><span class="line">    RbwAvg = <span class="built_in">int</span>(bw[<span class="number">2</span>] / <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    WbwMin = <span class="built_in">int</span>(bw[<span class="number">3</span>] / <span class="number">3</span>)</span><br><span class="line">    WbwMax = <span class="built_in">int</span>(bw[<span class="number">4</span>] / <span class="number">3</span>)</span><br><span class="line">    WbwAvg = <span class="built_in">int</span>(bw[<span class="number">5</span>] / <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    RiopsMin = <span class="built_in">int</span>(iops[<span class="number">3</span>] / <span class="number">3</span>)</span><br><span class="line">    RiopsMax = <span class="built_in">int</span>(iops[<span class="number">4</span>] / <span class="number">3</span>)</span><br><span class="line">    RiopsAvg = <span class="built_in">int</span>(iops[<span class="number">5</span>] / <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    WiopsMin = <span class="built_in">int</span>(iops[<span class="number">0</span>] / <span class="number">3</span>)</span><br><span class="line">    WiopsMax = <span class="built_in">int</span>(iops[<span class="number">1</span>] / <span class="number">3</span>)</span><br><span class="line">    WiopsAvg = <span class="built_in">int</span>(iops[<span class="number">2</span>] / <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">f&quot;\n\n\n随机读写均值如下:\n&quot;</span></span><br><span class="line">        <span class="string">f&quot;读:\n带宽最小值:<span class="subst">&#123;RbwMin&#125;</span>,最大值<span class="subst">&#123;RbwMax&#125;</span>,均值<span class="subst">&#123;RbwAvg&#125;</span>\nIOPS最小值:<span class="subst">&#123;RiopsMin&#125;</span>,&quot;</span></span><br><span class="line">        <span class="string">f&quot;最大值<span class="subst">&#123;RiopsMax&#125;</span>,均值<span class="subst">&#123;RiopsAvg&#125;</span>&quot;</span></span><br><span class="line">        <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">f&quot;写:\n带宽最小值:<span class="subst">&#123;WbwMin&#125;</span>,最大值<span class="subst">&#123;WbwMax&#125;</span>,均值<span class="subst">&#123;WbwAvg&#125;</span>\nIOPS最小值:<span class="subst">&#123;WiopsMin&#125;</span>,&quot;</span></span><br><span class="line">        <span class="string">f&quot;最大值<span class="subst">&#123;WiopsMax&#125;</span>,均值<span class="subst">&#123;WiopsAvg&#125;</span>&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rm_file</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请等待程序清除测试残留文件...&quot;</span>)</span><br><span class="line">    rm = os.system(<span class="string">&quot;rm -rf /smbTest/*&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;清除完毕,程序结束!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;欢迎使用群晖测试工具\n本工具测试内容:\n路径挂载模式下IOPS性能测试&quot;</span>)</span><br><span class="line">    rm_file()</span><br><span class="line">    randwrite()</span><br><span class="line">    rm_file()</span><br><span class="line">    create_readFile()</span><br><span class="line">    randread()</span><br><span class="line">    randrw()</span><br><span class="line">    rm_file()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>重庆奕宸电源无法正常Reset问题</title>
    <url>/%E9%87%8D%E5%BA%86%E5%A5%95%E5%AE%B8%E7%94%B5%E6%BA%90%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8Reset%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h2 id="重庆奕宸电源无法正常Reset问题"><a href="#重庆奕宸电源无法正常Reset问题" class="headerlink" title="重庆奕宸电源无法正常Reset问题"></a>重庆奕宸电源无法正常Reset问题</h2><h2 id="问题详情"><a href="#问题详情" class="headerlink" title="问题详情"></a>问题详情</h2><p>时间：2022&#x2F;10&#x2F;17<br>故障：在TyanS7106主板上完成一次正常启动后按PowerSW5秒强制断电，再次启动时在进入BIOS之前，自检过程中按ResetSW后异常断电无法启动</p>
<span id="more"></span>

<h2 id="提出疑问"><a href="#提出疑问" class="headerlink" title="提出疑问"></a>提出疑问</h2><ol>
<li>主板PowerSW和ResetSW给到电源的控制信号是否不同，是否可能存在Tyan给到电源的信号错误</li>
<li>IPMI日志是否有报告与电源相关的日志</li>
<li>电源的控制电路是否存在问题</li>
</ol>
<h2 id="寻找答案"><a href="#寻找答案" class="headerlink" title="寻找答案"></a>寻找答案</h2><ol>
<li>向电源厂商了解到：主板Power&#x2F;Reset SW给到电源的控制信号是由电源控制芯片输出高低电平，从而触发电源的响应，实现对电源的控制</li>
<li>IPMI日志报告PCH_P1V05&#x2F;PVNN&#x2F;P1V8，VCC3_AU 临界值过低，厂商回复该日志的意思是电压过低，属于正常现象，但经对比测试，其他电源无此现象。</li>
<li>主板控制电源的信号通用、电源响应主板控制信号的方式通用、排除主板和电源程序上的故障，和厂商进一步探讨后，得知电源收到PS-ON信号后，开机通常延迟300ms后输出PWR-OK信号，关机则是100ms，但关机的100ms延迟参数来源于网上非权威渠道，同时提出疑问，主板Reset的逻辑是怎样的？<blockquote>
<p>发出关机指令，等待电源回复PWR-OK后再次给出PS-ON完成开机？<br>还是发出PS-ON后，不等待电源返回PWR-OK，直接延迟一会儿后再次发出PS-ON进行开机？</p>
</blockquote>
</li>
<li>等待Tyan回复的同时，和电源厂家沟通安排测试，将关机100ms的延迟在多个主板上进行复现，观察是否存在错误：<blockquote>
<p>逐步递减100ms、80ms、60ms………<br>直接设置为最低值，无限接近0ms进行观测</p>
</blockquote>
</li>
<li>根据测试结果，将电源关机时序调整为最优默认值</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在发现问题时，善用对比法、排除法进行思路梳理</p>
]]></content>
      <categories>
        <category>知识库</category>
      </categories>
      <tags>
        <tag>电源</tag>
      </tags>
  </entry>
  <entry>
    <title>飞腾arm平台使用docker部署ftp教程</title>
    <url>/%E9%A3%9E%E8%85%BEarm%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2ftp%E6%95%99%E7%A8%8B.html</url>
    <content><![CDATA[<p><strong>因飞腾平台为armv8，暂未发现简单易用的vsftpd Docker镜像，特此提供打包完毕的Docker镜像及教程以供各位使用</strong></p>
<span id="more"></span>

<p><strong>该docker镜像为armv8版本，已测试适用飞腾2000平台</strong></p>
<p>第一步，拉取docker vsftpd映像</p>
<p><code>docker pull 1949hacker/vsftpd</code></p>
<p>如果你的环境为离线环境，则采用导入vsftpd映像方案</p>
<p><a href="http://117.176.215.230:20080/s/7PHKDK6qdb4Q8Qn/download?path=/docker%20images&files=1949hacker-vsftpd-arm.tar&downloadStartSecret=30n7yazxext">点此下载vsftpd映像</a></p>
<p>其他资料可访问：<a href="http://117.176.215.230:20080/s/7PHKDK6qdb4Q8Qn">http://117.176.215.230:20080/s/7PHKDK6qdb4Q8Qn</a></p>
<p>将下载的<code>1949hacker-vsftpd-arm.tar</code>导入到你的系统中，使用<code>docker load -i 1949hacker-vsftpd-arm.tar</code>将该映像导入</p>
<p>第二步，使用该映像启动容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先，创建一个路径用于存放ftp文件</span></span><br><span class="line">mkdir -p 路径</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例</span></span><br><span class="line">mkdir -p /opt/ftp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">请用你的参数替代&#123;参数&#125;内容</span></span><br><span class="line">docker run -d --name &#123;容器名&#125; -p 20:20 -p 21:21 -p 4559-4564:4559-4564 -e FTP_USER=&#123;ftp用户名&#125; -e FTP_PASSWORD=&#123;ftp密码&#125; -e PASV_ADDRESS=&#123;服务器地址&#125;  -e FTP_REPOSITORY=/opt/ftp -v &#123;主机FTP目录&#125;:/opt/ftp --restart=always oscarenzo/vsftpd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若无特别需求，仅更改“容器名、ftp用户名、密码、服务器地址”即可</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例如下</span></span><br><span class="line">docker run -d --name vsftpd-server -p 20:20 -p 21:21 -p 4559-4564:4559-4564 -e FTP_USER=ftptest -e FTP_PASSWORD=123456 -e PASV_ADDRESS=192.168.2.254 -e FTP_REPOSITORY=/opt/ftp -v /opt/ftp:/opt/ftp --restart=always f8044caf3727</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注：离线环境导入images需要将命令中的fauria/vsftpd替换为images ID f8044caf3727，如上方示例</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上述命令执行后可以使用docker ps查看容器是否运行成功</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">容器运行成功后修改本机FTP目录权限为777，示例</span></span><br><span class="line"></span><br><span class="line">chmod -R 777 /opt/ftp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker开机自动运行命令</span></span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>

<p>完整过程如下图所示，若有任何问题可以通过文末联系方式咨询</p>
<p><img src="https://img.1949hacker.cn//20230912213003.png" alt="20230912213003"></p>
]]></content>
      <categories>
        <category>知识库</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>apt等各种源列表（持续更新）</title>
    <url>/apt%E7%AD%89%E5%90%84%E7%A7%8D%E6%BA%90%E5%88%97%E8%A1%A8%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89.html</url>
    <content><![CDATA[<h1 id="操作系统源"><a href="#操作系统源" class="headerlink" title="操作系统源"></a>操作系统源</h1><p><strong>使用源时务必注意版本</strong></p>
<p>若你的系统不是最新版，可以使用<em>snullp</em>大佬开发的<a href="https://mirrors.ustc.edu.cn/repogen/">配置生成器</a></p>
<h2 id="中科大debian-apt源（最新debian12-bookworm版）"><a href="#中科大debian-apt源（最新debian12-bookworm版）" class="headerlink" title="中科大debian apt源（最新debian12 bookworm版）"></a>中科大debian apt源（最新debian12 bookworm版）</h2><p><strong>我个人觉得中科大源更好些，且在中科大下载iso也比清华快些，如需使用清华源，将ustc替换为tuna.tsinghua即可，其他配置同理</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb https://mirrors.ustc.edu.cn/debian/ bookworm main contrib non-free non-free-firmware</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/debian/ bookworm main contrib non-free non-free-firmware</span><br><span class="line"></span><br><span class="line">deb https://mirrors.ustc.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware</span><br><span class="line"></span><br><span class="line">deb https://mirrors.ustc.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware</span><br><span class="line"></span><br><span class="line">deb https://mirrors.ustc.edu.cn/debian-security/ bookworm-security main contrib non-free non-free-firmware</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/debian-security/ bookworm-security main contrib non-free non-free-firmware</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="中科大ubuntu-apt源（最新ubuntu24-04-noble源）"><a href="#中科大ubuntu-apt源（最新ubuntu24-04-noble源）" class="headerlink" title="中科大ubuntu apt源（最新ubuntu24.04 noble源）"></a>中科大ubuntu apt源（最新ubuntu24.04 noble源）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ noble main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ noble main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ noble-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ noble-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ noble-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ noble-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ noble-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ noble-backports main restricted universe multiverse</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Not recommended</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb https://mirrors.ustc.edu.cn/ubuntu/ noble-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.ustc.edu.cn/ubuntu/ noble-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure>

<h2 id="中科大docker-ce源（安装docker的源，一键自动安装）"><a href="#中科大docker-ce源（安装docker的源，一键自动安装）" class="headerlink" title="中科大docker ce源（安装docker的源，一键自动安装）"></a>中科大docker ce源（安装docker的源，一键自动安装）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh &amp;&amp; sudo DOWNLOAD_URL=https://mirrors.ustc.edu.cn/docker-ce sh get-docker.sh</span><br></pre></td></tr></table></figure>

<h1 id="软件源"><a href="#软件源" class="headerlink" title="软件源"></a>软件源</h1><h2 id="中科大docker-hub源"><a href="#中科大docker-hub源" class="headerlink" title="中科大docker hub源"></a>中科大docker hub源</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加以下内容</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn/&quot;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用root用户或具有sudo权限的用户加sudo后运行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h2 id="中科大npm源（反代的https-registry-npmjs-org-）"><a href="#中科大npm源（反代的https-registry-npmjs-org-）" class="headerlink" title="中科大npm源（反代的https://registry.npmjs.org/）"></a>中科大npm源（反代的<a href="https://registry.npmjs.org/%EF%BC%89">https://registry.npmjs.org/）</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑~/.npmrc</span></span><br><span class="line">registry=https://npmreg.proxy.ustclug.org/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时使用中科大源安装软件包</span></span><br><span class="line">npm --registry https://npmreg.proxy.ustclug.org/ install 包名</span><br></pre></td></tr></table></figure>

<h2 id="清华大学PyPI源阿里云PyPI源"><a href="#清华大学PyPI源阿里云PyPI源" class="headerlink" title="清华大学PyPI源阿里云PyPI源"></a><del>清华大学PyPI源</del>阿里云PyPI源</h2><p>中科大PyPI源公告：<br>由于 PyPI 源日益增长的空间与 mirror 磁盘空间非常有限的矛盾和用户报告的 PyPI 源的诸多问题，以及考虑到 PyPI 源的资源占用对其他镜像服务质量的影响，我们暂时移除了对 PyPI 的本地镜像。即日起至新的 PyPI 源镜像方案实施前，本站 PyPI 源的 HTTP 协议访问将重定向到 TUNA PyPI 源；PyPI 源的 RSYNC 同步方式停止提供。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时使用</span></span><br><span class="line">pip install -i https://mirrors.aliyun.com/pypi/simple/ package</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用清华镜像站来升级 pip</span></span><br><span class="line">pip install -i https://mirrors.aliyun.com/pypi/simple/ pip -U</span><br><span class="line">pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>

<h2 id="中科大Qt镜像"><a href="#中科大Qt镜像" class="headerlink" title="中科大Qt镜像"></a>中科大Qt镜像</h2><p><a href="https://mirrors.ustc.edu.cn/qtproject/official_releases/online_installers/">从中科大镜像下载Qt在线安装器</a></p>
<p>使用以下两种方式之一在安装器中配置使用科大源下载 Qt：</p>
<ol>
<li><p>（推荐）新版本的安装器（4.0.1-1 后）支持 –mirror 命令行参数。在命令行中执行安装器，添加 –mirror <a href="https://mirrors.ustc.edu.cn/qtproject">https://mirrors.ustc.edu.cn/qtproject</a> 参数。例如 Windows 下执行当前目录的安装器的命令为 .\qt-unified-windows-x86-online.exe –mirror <a href="https://mirrors.ustc.edu.cn/qtproject%EF%BC%9B">https://mirrors.ustc.edu.cn/qtproject；</a></p>
</li>
<li><p>或在启动安装器后在设置中禁用默认源，添加新源 <a href="http://mirrors.ustc.edu.cn/qtproject/online/qtsdkrepository/linux_x64/root/qt/">http://mirrors.ustc.edu.cn/qtproject/online/qtsdkrepository/linux_x64/root/qt/</a> （其他版本注意更改地址）。</p>
</li>
</ol>
<h2 id="github-release镜像（仅部分仓库）"><a href="#github-release镜像（仅部分仓库）" class="headerlink" title="github release镜像（仅部分仓库）"></a>github release镜像（仅部分仓库）</h2><p><a href="https://mirrors.tuna.tsinghua.edu.cn/github-release/">清华大学</a></p>
<p><a href="https://mirrors.ustc.edu.cn/github-release/">中科大</a></p>
]]></content>
      <categories>
        <category>知识库</category>
      </categories>
      <tags>
        <tag>apt源</tag>
        <tag>docker源</tag>
      </tags>
  </entry>
  <entry>
    <title>Proxmox-VE批量加集群、批量克隆、批量设置并同步时间、批量清除集群残留、批量创建网卡等一站式解决方案！（本教程采用YgeCloud实测）</title>
    <url>/Proxmox-VE%E6%89%B9%E9%87%8F%E5%8A%A0%E9%9B%86%E7%BE%A4%E3%80%81%E6%89%B9%E9%87%8F%E5%85%8B%E9%9A%86%E3%80%81%E6%89%B9%E9%87%8F%E8%AE%BE%E7%BD%AE%E5%B9%B6%E5%90%8C%E6%AD%A5%E6%97%B6%E9%97%B4%E3%80%81%E6%89%B9%E9%87%8F%E6%B8%85%E9%99%A4%E9%9B%86%E7%BE%A4%E6%AE%8B%E7%95%99%E3%80%81%E6%89%B9%E9%87%8F%E5%88%9B%E5%BB%BA%E7%BD%91%E5%8D%A1%E7%AD%89%E4%B8%80%E7%AB%99%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%81%EF%BC%88%E6%9C%AC%E6%95%99%E7%A8%8B%E9%87%87%E7%94%A8YgeCloud%E5%AE%9E%E6%B5%8B%EF%BC%89.html</url>
    <content><![CDATA[<hr>
<h2 id="本文章所有命令均在YgeCloud进行实测并列出了各种BUG，本文涉及的命令均为Linux-KVM-QEMU虚拟化通用命令，如命令有不兼容十分拜托您务必联系我修正文章！十分感谢！"><a href="#本文章所有命令均在YgeCloud进行实测并列出了各种BUG，本文涉及的命令均为Linux-KVM-QEMU虚拟化通用命令，如命令有不兼容十分拜托您务必联系我修正文章！十分感谢！" class="headerlink" title="本文章所有命令均在YgeCloud进行实测并列出了各种BUG，本文涉及的命令均为Linux KVM QEMU虚拟化通用命令，如命令有不兼容十分拜托您务必联系我修正文章！十分感谢！"></a><strong>本文章所有命令均在YgeCloud进行实测并列出了各种BUG，本文涉及的命令均为Linux KVM QEMU虚拟化通用命令，如命令有不兼容<em>十分拜托您务必联系我修正文章！十分感谢！</em></strong></h2><p><strong>以下命令中<code>10.0.1.$i</code>是因为本次批量部署节点均在10.0.1.0&#x2F;24段，需自行修改为你节点所在网段，如<code>192.168.100.$i</code></strong></p>
<p><strong>批量创建网卡适用于如本次部署一样的情况，如外网网线统一连接到enp6s0网口，然后桥接到vmbr1给虚拟机连接使用，请根据你的情况自行修改</strong></p>
<h2 id="批量加集群"><a href="#批量加集群" class="headerlink" title="批量加集群"></a>批量加集群</h2><span id="more"></span>

<p><em>更新：利用expect实现初次连接自动登陆或自动上传ssh key</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初次连接自动登陆</span></span><br><span class="line">expect -c &#x27;spawn ssh -o StrictHostKeyChecking=no root@10.0.1.$i; expect &quot;(yes/no)&quot; &#123; send &quot;yes\n&quot;; exp_continue &#125; &quot;assword:&quot; &#123; send &quot;密码\n&quot; &#125;; interact&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初次连接自动上传ssh key，便于后续免密连接批量执行命令</span></span><br><span class="line">expect -c &#x27;spawn ssh-copy-id -o StrictHostKeyChecking=no root@10.0.1.$i; expect &quot;(yes/no)&quot; &#123; send &quot;yes\n&quot;; exp_continue &#125; &quot;assword:&quot; &#123; send &quot;密码\n&quot; &#125;; interact&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量做免密连接</span></span><br><span class="line">for i in &#123;开始节点如104..结束节点如150&#125;; do expect -c &quot;spawn ssh-copy-id -o StrictHostKeyChecking=no root@10.0.1.$i; expect \&quot;(yes/no)\&quot; &#123; send \&quot;yes\n\&quot;; exp_continue &#125; \&quot;assword:\&quot; &#123; send \&quot;密码\n\&quot; &#125;; interact&quot; ; sleep 1 ; done</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从创建集群的主节点批量远程自动加集群</span></span><br><span class="line">for i in &#123;开始节点如104..结束节点如150&#125;; do ssh -t root@10.0.1.$i &quot;echo -e \&quot;密码\\nyes\&quot; | pvecm add 主节点完整IP如10.0.1.101 &amp;&amp; while true; do if pvecm status | grep -q $i; then echo -e \&quot;successfully\&quot;; break; else echo -e \&quot;Please wait a moment.\&quot;; sleep 5; fi; done&quot;; done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自动加集群示例</span></span><br><span class="line">for i in &#123;126..150&#125;; do ssh -t root@10.0.1.$i &quot;echo -e \&quot;密码\\nyes\&quot; | pvecm add 10.0.1.125 &amp;&amp; while true; do if pvecm status | grep -q $i; then echo -e \&quot;successfully\&quot;; break; else echo -e \&quot;Please wait a moment.\&quot;; sleep 5; fi; done&quot;; done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量自动创建vmbr1网卡</span></span><br><span class="line">for i in &#123;127..150&#125;; do ssh -t root@10.0.1.$i &#x27;echo -e &quot;auto vmbr1\niface vmbr1 inet manual\n\tbridge-ports enp6s0\n\tbridge-stp off\n\tbridge-fd 0&quot; &gt;&gt; /etc/network/interfaces &amp;&amp; systemctl restart networking&#x27;; done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从开始节点循环执行到结束节点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自动移除yge-data</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">扩容yge-root</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">刷新yge-root分区容量</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改时间服务器为10.0.1.110节点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启chrony.service</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制同步时间</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自动加入集群</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索当前ip比对pvecm status输出结果</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">未输出当前节点ip则持续提示等待</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出当前节点ip则表示加入集群成功，输出successfully</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">间隔5秒执行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量创建vmbr1网卡，桥接enp6s0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-- 命令为单行命令，严禁换行，”一条龙命令“ --</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因YgeCloud无sshpass工具，且新节点与主节点无免密登陆</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所以该命令需要手动输入ssh密码</span></span><br><span class="line"></span><br><span class="line">for i in &#123;开始节点如104..结束节点如150&#125;; do ssh -t root@10.0.1.$i &quot;lvremove -f /dev/yge/data &amp;&amp; lvextend -l +100%FREE /dev/yge/root &amp;&amp; resize2fs /dev/yge/root &amp;&amp; sed -i &#x27;s/pool 2.debian.pool.ntp.org/server 10.0.1.110/&#x27; /etc/chrony/chrony.conf &amp;&amp; systemctl restart chrony &amp;&amp; chronyc makestep &amp;&amp; sleep 3 &amp;&amp; date &amp;&amp; echo -e \&quot;密码\\nyes\&quot; | pvecm add 主节点完整IP如10.0.1.101 &amp;&amp; while true; do if pvecm status | grep -q $i; then echo -e \&quot;successfully\&quot;; break; else echo -e \&quot;Please wait a moment.\&quot;; sleep 5; fi; done &amp;&amp; echo -e \&quot;auto vmbr1\niface vmbr1 inet manual\n\tbridge-ports enp6s0\n\tbridge-stp off\n\tbridge-fd 0\&quot; &gt;&gt; /etc/network/interfaces &amp;&amp; systemctl restart networking&quot;; done</span><br></pre></td></tr></table></figure>

<h2 id="批量从模板恢复虚拟机，比克隆更骚的办法"><a href="#批量从模板恢复虚拟机，比克隆更骚的办法" class="headerlink" title="批量从模板恢复虚拟机，比克隆更骚的办法"></a>批量从模板恢复虚拟机，比克隆更骚的办法</h2><p><strong>vzdump生成的备份恢复时是根据名称匹配的，如果修改了命名会导致恢复失败，使用qmrestore恢复前一定要还原名称</strong></p>
<p><strong>如需临时命名以便区分备份文件，强烈建议添加前缀，不要修改原本的文件名！</strong></p>
<p><strong>-storage指向的目标存储不能为共享！否则会出现cfs无法锁定报错（local在集群中错误的设置为了共享发现的）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加了集群之后可以免密了！！！</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ssh连接到对应的子节点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行qmrestore命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/mnt/pve/backup/dump是YGENAS发布的NFS在集群存储添加为NFS挂载的位置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从 [你的备份文件名称] 备份文件批量恢复虚拟机并将虚拟机ID设置为当前节点ID，避免ID重复</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--store 指定恢复到<span class="built_in">local</span>存储</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--uniaue使恢复的虚拟机重设网卡MAC以防MAC冲突</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">恢复完成后使用qm <span class="built_in">set</span> VMID --name string命令重设虚拟机名为对应当前节点IP</span></span><br><span class="line">for i in &#123;125..150&#125;; do ssh -t root@10.0.1.$i &quot;qmrestore /mnt/pve/backup/dump/vzdump-qemu-2002-2024_02_04-16_44.vma.lzo $i -storage local -unique &amp;&amp; qm set $i --name g$i&quot;;done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并发恢复，将输出重定向到对应的<span class="variable">$i</span>.<span class="built_in">log</span>，避免ssh -t等待</span></span><br><span class="line">for i in &#123;125..150&#125;; do nohup ssh -t root@10.0.1.$i &quot;qmrestore /mnt/pve/backup/dump/vzdump-qemu-2002-2024_02_04-16_44.vma.lzo $i -storage local -unique &amp;&amp; qm set $i --name g$i&quot; &gt; $i.log 2&gt;&amp;1 &amp; done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">间隔1秒持续显示恢复进度</span></span><br><span class="line">while true; do bash -c &#x27;clear;for i in &#123;125..150&#125;; do echo $i ; tail -n 1 &quot;$i.log&quot;; done&#x27;; sleep 1; done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">排除rescan volumes...从而筛选出恢复失败的节点</span></span><br><span class="line">while true; do clear; for i in &#123;125..150&#125;; do tail -n 1 &quot;$i.log&quot; | grep -q &quot;update&quot; || &#123; echo &quot;$i error&quot;; &#125;; done; sleep 1; done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量删除克隆错误的虚拟机</span></span><br><span class="line">for i in &#123;125..150&#125;;do nohup ssh -t root@10.0.1.$i &quot;qm destroy $i&quot; &gt; del$i.log 2&gt;&amp;1 &amp; done</span><br></pre></td></tr></table></figure>

<h2 id="加错集群处理办法"><a href="#加错集群处理办法" class="headerlink" title="加错集群处理办法"></a>加错集群处理办法</h2><h3 id="主节点批量移除失效节点"><a href="#主节点批量移除失效节点" class="headerlink" title="主节点批量移除失效节点"></a>主节点批量移除失效节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除[104到124]的所有节点，yge是因为我的节点名前缀为yge，可以根据你的hostname来</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我的hostname输出为yge104</span></span><br><span class="line">for i in &#123;104..124&#125;; do pvecm delnode yge$i; done</span><br></pre></td></tr></table></figure>

<h3 id="在主节点删除后子节点会残留集群信息无法加入，需清除残留信息"><a href="#在主节点删除后子节点会残留集群信息无法加入，需清除残留信息" class="headerlink" title="在主节点删除后子节点会残留集群信息无法加入，需清除残留信息"></a>在主节点删除后子节点会残留集群信息无法加入，需清除残留信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一条龙清理</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从127开始清理到150，需在主节点执行，误加集群后主节点可以免密登陆子节点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先在主节点创建cleanup.sh脚本并<span class="built_in">chmod</span> +x cleanup.sh赋予可执行权限</span></span><br><span class="line">for i in &#123;127..150&#125;; do scp cleanup.sh root@10.0.1.$i:/tmp/ &amp;&amp; ssh -t root@10.0.1.$i &quot;bash /tmp/cleanup.sh&quot; &amp;&amp; ssh -t root@10.0.1.$i &quot;rm /tmp/cleanup.sh&quot;; done</span><br></pre></td></tr></table></figure>

<p><strong>因ssh -t无法处理!，所以迫不得已使用脚本执行</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">systemctl stop pve-cluster</span><br><span class="line">systemctl stop corosync</span><br><span class="line">pmxcfs -l</span><br><span class="line">rm /etc/pve/corosync.conf</span><br><span class="line">rm -rf /etc/corosync/*</span><br><span class="line">rm -rf /etc/pve/nodes/!(hostname)</span><br><span class="line">killall pmxcfs</span><br><span class="line">systemctl start pve-cluster</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>伟大的知识库</category>
      </categories>
      <tags>
        <tag>Proxmox-VE</tag>
        <tag>YgeCloud</tag>
        <tag>昱格</tag>
        <tag>批量</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux查询ssh日志判断是否被入侵及加强ssh安全的办法</title>
    <url>/Linux%E6%9F%A5%E8%AF%A2ssh%E6%97%A5%E5%BF%97%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E8%A2%AB%E5%85%A5%E4%BE%B5%E5%8F%8A%E5%8A%A0%E5%BC%BAssh%E5%AE%89%E5%85%A8%E7%9A%84%E5%8A%9E%E6%B3%95.html</url>
    <content><![CDATA[<h2 id="查询ssh登陆日志的办法"><a href="#查询ssh登陆日志的办法" class="headerlink" title="查询ssh登陆日志的办法"></a>查询ssh登陆日志的办法</h2><p><code>journalctl _COMM=sshd</code>可以查看sshd所有日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询ssh登陆失败总次数</span></span><br><span class="line">journalctl _COMM=sshd | grep Failed |wc -l</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查询ssh登陆成功总次数</span></span><br><span class="line">journalctl _COMM=sshd | grep Accepted |wc -l</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查询被多少不同IP爆破了</span></span><br><span class="line">journalctl _COMM=sshd | grep &quot;Failed&quot; | awk &#x27;&#123;print $(NF-3)&#125;&#x27; | sort -u | wc -l</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出爆破你的IP</span></span><br><span class="line">journalctl _COMM=sshd | grep &quot;Failed&quot; | awk &#x27;&#123;print $(NF-3)&#125;&#x27; | sort -u</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出成功登陆的IP</span></span><br><span class="line">journalctl _COMM=sshd | grep -E &quot;Accepted&quot; | awk &#x27;&#123;match($0, /([0-9]+\.)&#123;3&#125;[0-9]+/); print substr($0, RSTART, RLENGTH)&#125;&#x27; | sort -u</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="加强ssh安全的办法"><a href="#加强ssh安全的办法" class="headerlink" title="加强ssh安全的办法"></a>加强ssh安全的办法</h2><ol>
<li>禁用root密码登陆</li>
</ol>
<p>编辑<code>/etc/ssh/sshd_config</code>文件，默认会有<code>PermitRootLogin prohibit-password</code><br>保持默认的<code>prohibit-password</code>可使root用户密码登陆时一直提示密码错误，而不是直接提示禁止密码登陆，起到迷惑入侵者的作用</p>
<p>还可配置<code>PasswordAuthentication no</code>使普通用户也无法通过密码登陆并提示需要publickey</p>
<ol start="2">
<li>修改ssh服务端口</li>
</ol>
<p>编辑<code>/etc/ssh/sshd_config</code>文件，将默认的<code># Port 22</code>修改为<code>Port 20022</code>或其他符合规定的端口<br>修改端口后ssh连接时需要使用<code>-p 20022</code>指定端口<br>使用scp上传文件时也需要在scp命令后紧跟着使用<code>-P 20022</code>指定端口</p>
<ol start="3">
<li>ssh连接时使用指定的key进行验证</li>
</ol>
<p>ssh客户端在连接服务器时可以使用<code>-i</code>参数使用指定的id_rsa私钥进行连接，需要注意，id_rsa私钥文件权限需为600，也就是仅所有者可读写<br>使用root指定私钥访问20022端口的服务器示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -i ./myKeys/id_rsa -p 20022 root@192.168.2.254</span><br></pre></td></tr></table></figure>

<p>修改<code>sshd_config</code>文件后需要重启ssh服务，debian通常使用<code>systemctl restart ssh</code>即可</p>
]]></content>
      <categories>
        <category>知识库</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ssh</tag>
        <tag>网络安全</tag>
        <tag>ssh爆破</tag>
      </tags>
  </entry>
  <entry>
    <title>NAS（zfs）基础知识</title>
    <url>/NAS%EF%BC%88zfs%EF%BC%89%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
    <content><![CDATA[<h2 id="NAS是什么？"><a href="#NAS是什么？" class="headerlink" title="NAS是什么？"></a>NAS是什么？</h2><p>NAS，全称Network Attached Storage，翻译成中文就是网络附加存储。简单来说，它就是一个连接到网络上的存储设备，可以让多台电脑、智能手机、平板电脑等设备通过网络访问和共享存储空间。</p>
<span id="more"></span>

<p>NAS和传统的外接硬盘不同，它更像是一个小型的服务器，拥有自己的操作系统和处理器。你可以把NAS想象成一个能够存储大量文件的智能盒子，放在家里或者办公室的网络中，让你随时随地通过网络访问自己的文件。</p>
<p>使用NAS有很多好处。首先，它可以作为一个集中式的存储解决方案，让你不再需要把文件分散存储在各种设备上。其次，NAS通常具有数据备份和共享功能，可以保护你的文件免受丢失或损坏，并且可以让家人或团队成员轻松地共享文件。另外，NAS通常还提供了许多额外的功能，比如可以安装各种应用程序来扩展其功能，比如媒体服务器、下载站点等等。</p>
<p>总的来说，NAS就是一个连接到网络上的智能存储设备，可以让你方便地存储、备份和共享文件，是家庭和办公室网络存储的理想选择。</p>
<h2 id="NAS相对传统存储的优缺点"><a href="#NAS相对传统存储的优缺点" class="headerlink" title="NAS相对传统存储的优缺点"></a>NAS相对传统存储的优缺点</h2><table>
<thead>
<tr>
<th>优缺点</th>
<th>NAS</th>
<th>传统存储</th>
</tr>
</thead>
<tbody><tr>
<td>容量</td>
<td>可以轻松扩展容量</td>
<td>通常受限于单个设备的容量</td>
</tr>
<tr>
<td>可访问性</td>
<td>可通过网络从任何地方访问文件</td>
<td>需要直接连接到设备才能访问文件</td>
</tr>
<tr>
<td>共享功能</td>
<td>能够方便地与多个用户共享文件</td>
<td>通常只能由一个用户使用</td>
</tr>
<tr>
<td>备份</td>
<td>提供自动备份和恢复功能</td>
<td>需要手动进行备份和恢复</td>
</tr>
<tr>
<td>数据保护</td>
<td>提供数据冗余和RAID功能，增强数据保护</td>
<td>数据保护功能通常有限</td>
</tr>
<tr>
<td>扩展性</td>
<td>可以安装各种应用程序扩展功能</td>
<td>功能受限于设备自身的硬件和软件功能</td>
</tr>
<tr>
<td>成本</td>
<td>初始成本较高，但长期使用成本较低</td>
<td>初始成本较低，但随着存储需求增长成本可能增加</td>
</tr>
<tr>
<td>管理复杂性</td>
<td>需要一定的网络和技术知识来配置和管理</td>
<td>简单易用，不需要复杂的配置和管理</td>
</tr>
</tbody></table>
<h2 id="NAS-RAIDZ知识"><a href="#NAS-RAIDZ知识" class="headerlink" title="NAS RAIDZ知识"></a>NAS RAIDZ知识</h2><p>YGENAS采用zfs文件系统，可以创建RAIDZ软磁盘阵列，对比传统磁盘阵列如下</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>zfs软RAID</th>
<th>传统RAID</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>条带</td>
<td>Striping</td>
<td>RAID0</td>
<td>盘越多速度越快，安全性为0，掉盘则数据丢失</td>
</tr>
<tr>
<td>镜像</td>
<td>mirror</td>
<td>RAID1</td>
<td>安全性最高，传统RAID支持2个盘做镜像，一份数据存到2个盘上，软RAID则可以手动指定更多盘做镜像（通常没必要）</td>
</tr>
<tr>
<td>单重校验</td>
<td>RAID-Z1</td>
<td>RAID5</td>
<td>速度和安全性相对均衡，拥有1块校验盘所以可以允许单块盘故障</td>
</tr>
<tr>
<td>双重校验</td>
<td>RAID-Z2</td>
<td>RAID6</td>
<td>更偏向安全性，速度比单重校验略低，拥有3块校验盘所以可以允许2块盘故障</td>
</tr>
<tr>
<td>三重校验</td>
<td>RAID-Z3</td>
<td>无</td>
<td>软RAID特有，更安全但速度也低，拥有3块校验盘所以可以允许3块盘故障</td>
</tr>
<tr>
<td>组合RAID</td>
<td>可以将RAID1&#x2F;5&#x2F;6(RAID-Z3)，按条带方式组合，每个小RAID看作一块磁盘，如36盘分3组，每组12个盘做RAID5，最终组成RAID50，将12个为一组的RAID5看作一个大盘，这3个大盘做成一个RAID0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>热备盘</td>
<td>无论是软RAID还是传统RAID，都可以添加热备盘，热备盘用于替换故障盘，在新YGENAS系统中热备盘会在掉盘时自动替换。实际应用中可以给客户解释：当RAID5出现故障盘时，若存在热备盘，则会自动第一时间替换掉故障盘，因为人工介入处理故障需要一定时间，热备盘的自动替换可以防止在人工换盘之前又出现故障盘，若RAID5同时故障两块盘则会丢失数据</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="NAS-RAIDZ容量计算方法"><a href="#NAS-RAIDZ容量计算方法" class="headerlink" title="NAS RAIDZ容量计算方法"></a>NAS RAIDZ容量计算方法</h2><p><a href="https://wintelguy.com/zfs-calc.pl">ZFS &#x2F; RAIDZ容量估算</a></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>RAID type</td>
<td>RAID类型，对应上面介绍的RAID-Z1&#x2F;2&#x2F;3等</td>
</tr>
<tr>
<td>Drive capacity(GB)</td>
<td>单个磁盘容量，单位为GB，1TB&#x3D;1000GB</td>
</tr>
<tr>
<td>Number of drives per RAID group</td>
<td>每组RAID中磁盘的数量，单组RAID-Z1&#x2F;2&#x2F;3均不建议超过12块盘，否则故障时重建时间过长可能存在风险</td>
</tr>
<tr>
<td>Number of RAID groups</td>
<td>多重RAID的数量，比如RAID50&#x2F;60，该项则是对应多少组RAID5&#x2F;6组成RAID50&#x2F;60，比如36盘位通常由3组12盘的RAID-Z1组成一组RAID-Z1条带，也就是RAID50</td>
</tr>
<tr>
<td>20% free space limit</td>
<td>该参数是因为NAS在占用空间超过80%后性能会下降，所以会有一个20%空闲空间限制，但是该项默认是不勾选的，忽略即可</td>
</tr>
<tr>
<td>Practical usable storage capacity</td>
<td>实际可用存储容量，单位分别有TiB和TB，通常俗称的容量一般为TB，TiB是操作系统以1024GiB&#x3D;1TiB为进制计算的空间</td>
</tr>
<tr>
<td>Single drive cost</td>
<td>单块硬盘价格，如果需要计算每TiB存储空间的成本，可以填写该项用于计算</td>
</tr>
<tr>
<td>Cost per TiB usable</td>
<td>每TiB存储空间成本</td>
</tr>
<tr>
<td>其他项在常见情况下也忽略即可</td>
<td></td>
</tr>
</tbody></table>
<p>以下是YGENAS-RH12按12个16TB硬盘做RAID-Z1的容量计算和成本计算（硬盘价格1600乱填的）：</p>
<p><img src="https://img.1949hacker.cn//ad900b1ecf2520cd6c46787268124ed.png" alt="ad900b1ecf2520cd6c46787268124ed"></p>
<p><img src="https://img.1949hacker.cn//20240405190455.png" alt="20240405190455"></p>
<h2 id="RAID-Z1-x2F-2-x2F-3速度估算"><a href="#RAID-Z1-x2F-2-x2F-3速度估算" class="headerlink" title="RAID-Z1&#x2F;2&#x2F;3速度估算"></a>RAID-Z1&#x2F;2&#x2F;3速度估算</h2><p>首先需要知道硬盘的官方数据用于参考，以公司常见的西数16TB WUH721816ALE6L4型号硬盘为例，在bing.com搜索到<a href="https://www.westerndigital.com/zh-cn/products/internal-drives/data-center-drives/ultrastar-dc-hc550-hdd?sku=0F38462">西数官方数据</a></p>
<p><img src="https://img.1949hacker.cn//20240405191501.png" alt="20240405191501"></p>
<p>这里采用官方的理论速度做为参考（<strong>仅做为参考，实际速度没有任何人能准确计算，绝不可以此做为承诺</strong>）</p>
<hr>
<p><strong>注意，因为存储系统的复杂性，在此只能给出最最最简单的估算，该估算值为极限最优状态下的最高理论速度，严禁以此估算结果给用户承诺实际速度！！！</strong></p>
<p>影响NAS实际速度的部分因素有：</p>
<ol>
<li>单个硬盘速度</li>
<li>磁盘阵列模式：奇偶校验、数据盘</li>
<li>驱动器扇区大小</li>
<li>ZFS记录大小</li>
<li>应用数据块大小</li>
<li>IO模式：异步&#x2F;同步</li>
<li>IO队列深度</li>
<li>CPU、内存性能</li>
<li>网络传输速度：NAS网卡速度，局域网链路速度，客户端网卡速度缺一不可，每一项短板都会限制实际速度</li>
<li>客户端读写速度</li>
</ol>
<hr>
<p>简单估算速度的方法</p>
<p>n为单组阵列磁盘数量</p>
<table>
<thead>
<tr>
<th>阵列类型</th>
<th>估算方法</th>
<th>12盘位示例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>RAID-Z1</td>
<td>单盘速度*(n-1)</td>
<td>262*(12-1)&#x3D;2882MB&#x2F;s</td>
<td>12个盘组成一个RAID5</td>
</tr>
<tr>
<td>RAID-Z2</td>
<td>单盘速度*(n-2)</td>
<td>262*(12-2)&#x3D;2620MB&#x2F;s</td>
<td>12个盘组成一个RAID6</td>
</tr>
<tr>
<td>RAID-Z3</td>
<td>单盘速度*(n-3)</td>
<td>262*(12-3)&#x3D;2358MB&#x2F;s</td>
<td>12个盘组成一个RAID7</td>
</tr>
<tr>
<td>RAID-Z10</td>
<td>单盘速度*(n-1)*磁盘组数量</td>
<td>262*(6-1)*2&#x3D;2620MB&#x2F;s</td>
<td>12个盘组成2个RAID5</td>
</tr>
<tr>
<td>RAID-Z20</td>
<td>单盘速度*(n-2)*磁盘组数量</td>
<td>262*(6-2)*2&#x3D;2096MB&#x2F;s</td>
<td>12个盘组成2个RAID6</td>
</tr>
<tr>
<td>RAID-Z30</td>
<td>单盘速度*(n-3)*磁盘组数量</td>
<td>262*(6-3)*2&#x3D;1572MB&#x2F;s</td>
<td>12个盘组成2个RAID7</td>
</tr>
</tbody></table>
<p><strong>以上计算方法仅可做为参考，因为实际使用环境的复杂性，做为参考给用户进行解释时，需将速度减半估计，如12个16TB盘（262MB&#x2F;s）组单RAID-Z1，只可预估有1441MB&#x2F;s速度，甚至更低，尤其是小文件（大量几KB，几MB的文件）传输时，速度会严重降低，属于正常现象。</strong></p>
]]></content>
      <categories>
        <category>知识库</category>
      </categories>
      <tags>
        <tag>NAS</tag>
        <tag>ZFS</tag>
        <tag>RAID</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title>未整理的随手技术笔记（实时更新，各种乱七八糟的技术都会记录在这儿）</title>
    <url>/%E6%9C%AA%E6%95%B4%E7%90%86%E7%9A%84%E9%9A%8F%E6%89%8B%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%88%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0%EF%BC%8C%E5%90%84%E7%A7%8D%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E7%9A%84%E6%8A%80%E6%9C%AF%E9%83%BD%E4%BC%9A%E8%AE%B0%E5%BD%95%E5%9C%A8%E8%BF%99%E5%84%BF%EF%BC%89.html</url>
    <content><![CDATA[<h2 id="以下是乱七八糟的各种没时间整理的随手技术笔记，你可以通过页面搜索关键词查询可能是你用得上的东西，也可以通过底部联系方式询问我"><a href="#以下是乱七八糟的各种没时间整理的随手技术笔记，你可以通过页面搜索关键词查询可能是你用得上的东西，也可以通过底部联系方式询问我" class="headerlink" title="以下是乱七八糟的各种没时间整理的随手技术笔记，你可以通过页面搜索关键词查询可能是你用得上的东西，也可以通过底部联系方式询问我"></a>以下是乱七八糟的各种没时间整理的随手技术笔记，你可以通过页面搜索关键词查询可能是你用得上的东西，也可以通过底部联系方式询问我</h2><p>点击阅读全文查看</p>
<span id="more"></span>

<h3 id="CentOS-7批量给eth0网卡添加IP"><a href="#CentOS-7批量给eth0网卡添加IP" class="headerlink" title="CentOS 7批量给eth0网卡添加IP"></a>CentOS 7批量给eth0网卡添加IP</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过变量d实现改一个128使所有D段地址同步修改</span></span><br><span class="line">d=128 &amp;&amp; echo -e &quot;IPADDR2=43.225.58.$d\nPREFIX2=27\nIPADDR3=69.165.77.$d\nPREFIX3=27\nIPADDR4=103.42.29.$d \nPREFIX4=27\nIPADDR5=220.158.194.$d \nPREFIX5=27\nIPADDR6=220.158.195.$d \nPREFIX6=27\nIPADDR7=107.151.236.$d \nPREFIX7=27\nIPADDR8=107.151.237.$d \nPREFIX8=27\nIPADDR9=198.44.163.$d \nPREFIX9=27\n&quot; &gt;&gt; /etc/sysconfig/network-scripts/ifcfg-eth0 &amp;&amp; systemctl restart network</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>知识库</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>NAS</tag>
        <tag>存储</tag>
        <tag>IT技术</tag>
        <tag>知识库</tag>
        <tag>随手记</tag>
        <tag>网络</tag>
        <tag>虚拟化</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>相片硅脂片知识</title>
    <url>/%E7%9B%B8%E7%89%87%E7%A1%85%E8%84%82%E7%89%87%E7%9F%A5%E8%AF%86.html</url>
    <content><![CDATA[<h2 id="相变硅脂（相变）原理"><a href="#相变硅脂（相变）原理" class="headerlink" title="相变硅脂（相变）原理"></a>相变硅脂（相变）原理</h2><p>相变（Phase Change）是物质从一种物理状态转变为另一种状态的过程，通常涉及到固态、液态和气态之间的转变。相变过程发生时，物质的温度保持不变，而是在改变物质状态的同时吸收或释放潜热（latent heat）。潜热是单位质量物质在相变过程中吸收或释放的热量，它是相变过程中热量变化的主要来源。</p>
<p>通俗解释：一杯水中放2块冰块，冰块完全融化前水温始终0度，形态未完全转化前，温度不变</p>
<h2 id="相变硅脂特点"><a href="#相变硅脂特点" class="headerlink" title="相变硅脂特点"></a>相变硅脂特点</h2><p>相变特性使得相变硅脂片拥有更长的寿命，更优的散热稳定性，相变硅脂片高温相变时液化的表面可以排出空气使得硅脂更加贴合散热元件表面</p>
<p>以霍尼韦尔PTM7950相变片为例，150℃的温度下不会完全相变液化，仅表面相变液化，增加贴合度的情况下不整体液化流动，温度稳定导热高效，官方参数导热率8.5W&#x2F;mk热阻0.04℃cm²&#x2F;W</p>
]]></content>
      <categories>
        <category>知识库</category>
      </categories>
      <tags>
        <tag>相变</tag>
        <tag>相变硅脂</tag>
      </tags>
  </entry>
  <entry>
    <title>IT基础知识百科</title>
    <url>/IT%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%99%BE%E7%A7%91.html</url>
    <content><![CDATA[<h2 id="常见的SAS线缆"><a href="#常见的SAS线缆" class="headerlink" title="常见的SAS线缆"></a>常见的SAS线缆</h2><p><a href="https://cs-electronics.com/">一个非常优秀的、介绍各种线缆知识的网站</a></p>
<h3 id="SFF-8643-amp-MINI-SAS-HD"><a href="#SFF-8643-amp-MINI-SAS-HD" class="headerlink" title="SFF-8643 &amp; MINI SAS HD"></a>SFF-8643 &amp; MINI SAS HD</h3><p><strong>通常JBOD磁盘柜使用的，在机箱外部连接的有保护壳的是SFF-8644</strong></p>
<span id="more"></span>

<p><img src="https://img.1949hacker.cn/2022-10-25-10-45-40.png" alt="2022-10-25-10-45-40"></p>
<h3 id="SFF-8087-amp-MINI-SAS"><a href="#SFF-8087-amp-MINI-SAS" class="headerlink" title="SFF-8087 &amp; MINI SAS"></a>SFF-8087 &amp; MINI SAS</h3><p><img src="https://img.1949hacker.cn/2022-10-25-10-46-10.png" alt="2022-10-25-10-46-10"></p>
<h3 id="SFF-8654-amp-SLIM-SAS"><a href="#SFF-8654-amp-SLIM-SAS" class="headerlink" title="SFF-8654 &amp; SLIM SAS"></a>SFF-8654 &amp; SLIM SAS</h3><p>YGR-822平台便有大量SlimSAS用于PCIe扩展连接</p>
<p><img src="https://img.1949hacker.cn/2022-10-25-10-44-50.png" alt="2022-10-25-10-44-50"></p>
<h2 id="机房最常见的光纤及其模块和名称"><a href="#机房最常见的光纤及其模块和名称" class="headerlink" title="机房最常见的光纤及其模块和名称"></a>机房最常见的光纤及其模块和名称</h2><h3 id="最最最普遍的万兆光纤"><a href="#最最最普遍的万兆光纤" class="headerlink" title="最最最普遍的万兆光纤"></a>最最最普遍的万兆光纤</h3><p><img src="https://img.1949hacker.cn//20240405213514.png" alt="20240405213514"></p>
<p>外观上可以分辨的：两头都是LC接口</p>
<p>重要参数：</p>
<ol>
<li>频率：850nm</li>
<li>模式：多模</li>
<li>距离：&lt;300m</li>
<li>规格：OM3</li>
</ol>
<p>规格参数（OM）解读：</p>
<table>
<thead>
<tr>
<th>规格</th>
<th>10Gb传输距离（米）</th>
<th>性能</th>
<th>带宽</th>
<th>颜色</th>
</tr>
</thead>
<tbody><tr>
<td>OM3</td>
<td>300</td>
<td>10Gb&#x2F;s</td>
<td>2000MHz&#x2F;KM</td>
<td>水蓝色</td>
</tr>
<tr>
<td>OM4</td>
<td>550</td>
<td>40&#x2F;100Gb&#x2F;s</td>
<td>4700MHz&#x2F;KM</td>
<td>水蓝色</td>
</tr>
<tr>
<td>OM5</td>
<td>550</td>
<td>40&#x2F;100&#x2F;200&#x2F;400Gb&#x2F;s</td>
<td>28000MHz&#x2F;KM</td>
<td>水绿色</td>
</tr>
</tbody></table>
<h3 id="机房常见光模块"><a href="#机房常见光模块" class="headerlink" title="机房常见光模块"></a>机房常见光模块</h3><table>
<thead>
<tr>
<th>型号</th>
<th>俗称</th>
<th>速率</th>
<th>补充</th>
</tr>
</thead>
<tbody><tr>
<td>SFP</td>
<td>千兆光模块</td>
<td>100~4000Mb&#x2F;s</td>
<td>淘汰产品</td>
</tr>
<tr>
<td>SFP+</td>
<td>万兆光模块</td>
<td>10Gb&#x2F;s</td>
<td>主流产品，机房常用LC接口</td>
</tr>
<tr>
<td>SFP28</td>
<td>25G光模块</td>
<td>25Gb&#x2F;s</td>
<td>比较常用</td>
</tr>
<tr>
<td>QSFP+</td>
<td>40G光模块</td>
<td>40Gb&#x2F;s</td>
<td>还行</td>
</tr>
<tr>
<td>QSFP28</td>
<td>100G光模块</td>
<td>100Gb&#x2F;s</td>
<td>很牛逼</td>
</tr>
</tbody></table>
<h2 id="网线类型"><a href="#网线类型" class="headerlink" title="网线类型"></a>网线类型</h2><table>
<thead>
<tr>
<th>规格</th>
<th>俗称</th>
<th>传输速度</th>
<th>频率带宽</th>
<th>传输距离m</th>
</tr>
</thead>
<tbody><tr>
<td>CAT5</td>
<td>五类</td>
<td>100Mbps</td>
<td>100MHz</td>
<td>100</td>
</tr>
<tr>
<td>CAT5E</td>
<td>超五类</td>
<td>1000Mbps</td>
<td>100MHz</td>
<td>100（1Gbps）</td>
</tr>
<tr>
<td>CAT6</td>
<td>六类</td>
<td>10Gbps</td>
<td>250MHz</td>
<td>55（10Gbps）</td>
</tr>
<tr>
<td>CAT6A</td>
<td>超六类</td>
<td>10Gbps</td>
<td>500MHz</td>
<td>100（10Gbps）</td>
</tr>
<tr>
<td>CAT7</td>
<td>七类</td>
<td>10Gbps</td>
<td>600Mhz</td>
<td>100（10Gbps）</td>
</tr>
<tr>
<td>CAT8</td>
<td>八类</td>
<td>25&#x2F;40Gbps</td>
<td>2000MHz</td>
<td>30</td>
</tr>
</tbody></table>
<p>非屏蔽：UTP（不抗干扰）<br>屏蔽：STP（抗干扰，前提是设备必须接地，否则电磁干扰会在屏蔽层内反弹加剧干扰）</p>
<h2 id="内存类型"><a href="#内存类型" class="headerlink" title="内存类型"></a>内存类型</h2><table>
<thead>
<tr>
<th>型号</th>
<th>俗称</th>
<th>区别</th>
</tr>
</thead>
<tbody><tr>
<td>non-ECC</td>
<td>普条</td>
<td>家用，没有数据纠错功能</td>
</tr>
<tr>
<td>SODIMM</td>
<td>小内存</td>
<td>笔记本用</td>
</tr>
<tr>
<td>unbuffered-ECC&#x2F;UDIMM</td>
<td>服务器条</td>
<td>服务器专用，带ECC纠错但没有缓存寄存器，家用电脑、不支持ECC的主板均无法使用</td>
</tr>
<tr>
<td>REG ECC&#x2F;RDIMM</td>
<td>大容量内存</td>
<td>服务器专用，因为大容量颗粒CPU无法直接驱动，所以需要一颗寄存器来做中转，常见于32GB以上内存</td>
</tr>
<tr>
<td>LRDIMM</td>
<td>低电压大容量内存</td>
<td>服务器专用，通过使用简单寄存器降低供电需求从而支持更大容量更多颗粒，常见于128G内存条</td>
</tr>
<tr>
<td>DDR2</td>
<td>2代内存</td>
<td>频率：400-1066MHz</td>
</tr>
<tr>
<td>DDR3</td>
<td>3代内存</td>
<td>频率：800-2133MHz</td>
</tr>
<tr>
<td>DDR4</td>
<td>4代内存</td>
<td>频率：1600-3200MHz</td>
</tr>
<tr>
<td>DDR5</td>
<td>5代内存</td>
<td>频率：3000-4000MHz（现在普遍用MT&#x2F;s为单位，也就是6000-8000MT&#x2F;s）</td>
</tr>
</tbody></table>
<p>Intel除至强CPU外均不支持ECC内存</p>
<p>AMD部分Ryzen消费级CPU也支持ECC，以实际说明为准</p>
<p>小知识：观察内存条颗粒，单侧颗粒数量为偶数（通常为8颗）的，就是家用non-ECC内存，ECC内存则会多一颗颗粒用于数据校验（有点像RAID5），而有一大堆颗粒，其中还有一颗与众不同的大颗粒的，不用怀疑，那就是服务器专用的大容量RECC内存</p>
<p>花里胡哨的家用金士顿屌炸天DDR5 8000MT&#x2F;s内存</p>
<p><img src="https://img.1949hacker.cn//20240405222648.png" alt="花里胡哨的家用金士顿屌炸天DDR5 8000MT/s内存"></p>
<p>服务器RECC内存，中间那个大颗粒就是缓存寄存器</p>
<p><img src="https://img.1949hacker.cn//20240405222930.png" alt="服务器RECC内存，中间那个大颗粒就是缓存寄存器"></p>
<h2 id="硬盘类型"><a href="#硬盘类型" class="headerlink" title="硬盘类型"></a>硬盘类型</h2><p>HDD：Hard Disk Drive，硬盘驱动器，传统硬盘，俗称机械硬盘<br>SSD：Solid State Drive，固态硬盘</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>类型</th>
<th>速度</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>SATA</td>
<td>HDD</td>
<td>100-250MB&#x2F;s</td>
<td>便宜皮实容量大，但速度慢</td>
</tr>
<tr>
<td>SAS</td>
<td>HDD</td>
<td>100-1200MB&#x2F;s</td>
<td>貌似是个挺鸡肋的东西？技术更新迭代的过渡品？</td>
</tr>
<tr>
<td>SATA</td>
<td>SSD</td>
<td>300-600MB&#x2F;s</td>
<td>性价比相对较高，基本一个顶4个机械</td>
</tr>
<tr>
<td>NVMe M.2</td>
<td>SSD</td>
<td>500-3500MB&#x2F;s</td>
<td>价格比较高，速度非常快，体积也小，现在的主流硬盘</td>
</tr>
<tr>
<td>U.2(SFF-8639)</td>
<td>SSD</td>
<td>1000-5000MB&#x2F;s</td>
<td>价格超高，性能超屌，高端存储常用</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>接口</th>
<th>尺寸</th>
</tr>
</thead>
<tbody><tr>
<td>SATA</td>
<td>机械盘：3.5&#x2F;2.5寸，SSD：2.5寸</td>
</tr>
<tr>
<td>SAS</td>
<td>机械盘：3.5&#x2F;2.5寸</td>
</tr>
<tr>
<td>m.2</td>
<td>常见：2226&#x2F;2230&#x2F;2242&#x2F;2260&#x2F;2280&#x2F;22110</td>
</tr>
<tr>
<td>U.2</td>
<td>固态盘：比SATA 2.5寸厚一点</td>
</tr>
</tbody></table>
<p>SATA接口的SSD，和SATA机械盘一样的接口</p>
<p><img src="https://img.1949hacker.cn//20240405223803.png" alt="SATA接口的SSD，和SATA机械盘一样的接口"></p>
<p>SAS接口的HDD</p>
<p><img src="https://img.1949hacker.cn//20240405224330.png" alt="SAS接口的HDD"></p>
<p>M.2接口的SSD</p>
<p><img src="https://img.1949hacker.cn//20240405224108.png" alt="M.2接口的SSD"></p>
<p>U.2接口的SSD</p>
<p><img src="https://img.1949hacker.cn//20240405224240.png" alt="U.2接口的SSD"></p>
<h2 id="主板常见接口"><a href="#主板常见接口" class="headerlink" title="主板常见接口"></a>主板常见接口</h2><table>
<thead>
<tr>
<th>名称</th>
<th>俗称</th>
<th>作用</th>
<th>最新版本</th>
<th>性能</th>
</tr>
</thead>
<tbody><tr>
<td>PS&#x2F;2</td>
<td>键鼠接口</td>
<td>相当传统的古董键鼠接口</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>VGA</td>
<td>显示器接口</td>
<td>最原始的显示器接口</td>
<td>无</td>
<td>1k60Hz</td>
</tr>
<tr>
<td>DVI</td>
<td>显示器接口</td>
<td>相对先进一些</td>
<td>24+5</td>
<td>2k120Hz</td>
</tr>
<tr>
<td>HDMI</td>
<td>高清显示器接口</td>
<td>最普遍</td>
<td>2.1</td>
<td>8k30Hz</td>
</tr>
<tr>
<td>DP</td>
<td>高清显示器接口</td>
<td>最先进</td>
<td>2.0</td>
<td>8k60Hz</td>
</tr>
<tr>
<td>COM</td>
<td>串口</td>
<td>传统调试接口，9针</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>USB Type-A</td>
<td>USB口</td>
<td>我们常说的USB口，方形</td>
<td>3.1 Gen 2</td>
<td>10Gbps</td>
</tr>
<tr>
<td>USB Typc-C</td>
<td>C口、华为口</td>
<td>现在主流的手机充电口，也被部分人成为“华为充电器”</td>
<td>USB 4 Gen 3x2</td>
<td>40Gbps</td>
</tr>
<tr>
<td>RJ45</td>
<td>网线电口</td>
<td>插网线上网，在服务器上通常是紧挨着的两个网口，避免与单独的BMC口混淆</td>
<td>无</td>
<td>10Gbps</td>
</tr>
<tr>
<td>SFP+</td>
<td>万兆光口</td>
<td>插光模块连光纤</td>
<td>无</td>
<td>10Gbps</td>
</tr>
<tr>
<td>BMC</td>
<td>IPMI管理口</td>
<td>通常用于服务器远程管理，一般位于USB上方</td>
<td>无</td>
<td>通常为千兆</td>
</tr>
<tr>
<td>3.5mm</td>
<td>耳机口</td>
<td>通常有红绿蓝三孔或2合1的手机那种3.5mm孔</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>PCIe</td>
<td>PCIe</td>
<td>从尺寸上分为x1&#x2F;4&#x2F;8&#x2F;16，但是即便是x16尺寸，内部仍然有可能是x4信号，以主板设置或说明为准</td>
<td>PCIe 7.x</td>
<td>x1信号32GB&#x2F;s速率</td>
</tr>
<tr>
<td>3pin</td>
<td>3针风扇接口</td>
<td>插机箱风扇，没有温控调速，插上就满速运转</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>4pin</td>
<td>4针温控风扇接口</td>
<td>插机箱风扇、CPU风扇（CPU风扇插针有专门的丝印标注），有温控调速，根据温度提升转速</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>SATA DOM</td>
<td>迷你SSD</td>
<td>只有一个SATA接口，部分有额外供电口，一种非常小的SSD，直接插在SATA DOM接口即可使用</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>SD</td>
<td>SD卡</td>
<td>SD卡并不是手机中的小存储卡（TF卡），SD卡是相机里常用的大卡，下方附图</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>TF</td>
<td>TF卡</td>
<td>手机里常用的很小很小的存储卡，摄像机，行车记录仪等都很常用</td>
<td>无</td>
<td>无</td>
</tr>
</tbody></table>
<p>SD大卡</p>
<p><img src="https://img.1949hacker.cn//20240405231336.png" alt="SD大卡"></p>
<p>TF小卡</p>
<p><img src="https://img.1949hacker.cn//20240405231412.png" alt="TF小卡"></p>
<h2 id="GPU知识"><a href="#GPU知识" class="headerlink" title="GPU知识"></a>GPU知识</h2><p>NVIDIA GPU通常分为：游戏卡、公版、涡轮卡</p>
<p>游戏卡通常是华硕，七彩虹等第三方生产的卡，其尺寸通常没有固定的标准，难以安装到服务器或安装双GPU</p>
<p>公版（Founder’s Edition）是由NVIDIA官方设计的GPU，在NVIDIA官网可以查询到其尺寸信息，价格似乎也比较昂贵</p>
<p>涡轮卡（Turbo Edition）涡轮版，也是最贵的，尺寸为标准的固定尺寸，通常为单宽，双宽，便于安装到高密度的GPU服务器中，但需要注意涡轮进风口的散热空间，尽量不要阻挡</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
<th>A100 80GB PCIe版示例</th>
</tr>
</thead>
<tbody><tr>
<td>FP64</td>
<td>64位双精度浮点数</td>
<td>9.7TFLOPS</td>
</tr>
<tr>
<td>FP64 Tensor Core</td>
<td>一种精度格式，它支持半精度（FP16）数据来加速矩阵乘法，并使用单精度（FP32）或双精度（FP64）数据来修正结果，以获得更高的精度</td>
<td>19.5TFLOPS</td>
</tr>
<tr>
<td>FP32</td>
<td>32位单精度浮点数</td>
<td>19.5TFLOPS</td>
</tr>
<tr>
<td>TF32</td>
<td>一种截短的 Float32 数据格式，将 FP32 中 23 个尾数位截短为 10 bits，而指数位仍为 8 bits，总长度为 19 (&#x3D;1 + 8 + 10) bits</td>
<td>156 TFLOPS&#x2F;312 TFLOPS</td>
</tr>
<tr>
<td>BFLOAT16 Tensor Core</td>
<td>一种支持低精度浮点数（BFloat16）计算的计算单元，主要用于深度学习等大规模并行计算场景</td>
<td>312 TFLOPS&#x2F;624 TFLOPS</td>
</tr>
<tr>
<td>FP16 Tensor Core</td>
<td>一种支持半精度（FP16）浮点数计算的计算单元，主要用于深度学习等大规模并行计算场景</td>
<td>312 TFLOPS&#x2F;624 TFLOPS</td>
</tr>
<tr>
<td>INT8 Tensor Core</td>
<td>一种针对深度学习等大规模并行计算场景的专用矩阵运算单元，它首次出现在Volta架构的GPU中，并在后续的Turing和Ampere架构中得到发展</td>
<td>624 TOPS&#x2F;1248 TOPS</td>
</tr>
<tr>
<td>GPU Memory</td>
<td>GPU内存</td>
<td>80GB HBM2e</td>
</tr>
<tr>
<td>GPU Memory Bandwidth</td>
<td>GPU内存带宽</td>
<td>1935GB&#x2F;s</td>
</tr>
<tr>
<td>Max Thermal Design Power (TDP)</td>
<td>GPU最大功耗</td>
<td>300W</td>
</tr>
</tbody></table>
<h2 id="Windows操作系统"><a href="#Windows操作系统" class="headerlink" title="Windows操作系统"></a>Windows操作系统</h2><p>Windows消费级：</p>
<p>已弃用版本：Windows XP、7、8、8.1</p>
<p>即将弃用版本：Windows 10</p>
<p>主流版：Windows 11</p>
<p>Windows 11版本：家庭版、专业版、企业版、教育版、专业工作站版、IoT物联网嵌入式版（也叫Emb）、Team团队版</p>
<p>通常安装企业版即可，Windows 10、11互联网激活方式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以管理员权限运行cmd或powershell</span></span><br><span class="line">slmgr /ipk 序列号</span><br><span class="line">slmgr /skms kms服务器</span><br><span class="line">slmgr /ato</span><br></pre></td></tr></table></figure>

<p>常用KMS服务器：kms.03k.org</p>
<p><a href="https://www.coolhub.top/tech-articles/kms_list.html">KMS服务器状态查询网站</a></p>
<table>
<thead>
<tr>
<th>版本</th>
<th>KMS序列号</th>
</tr>
</thead>
<tbody><tr>
<td>家庭版</td>
<td>TX9XD-98N7V-6WMQ6-BX7FG-H8Q99</td>
</tr>
<tr>
<td>专业版</td>
<td>W269N-WFGWX-YVC9B-4J6C9-T83GX</td>
</tr>
<tr>
<td>企业版</td>
<td>NPPR9-FWDCX-D2C8J-H872K-2YT43</td>
</tr>
<tr>
<td>教育版</td>
<td>NW6C2-QMPVW-D7KKK-3GKT6-VCFB2</td>
</tr>
<tr>
<td>专业工作站版</td>
<td>NRG8B-VKK3Q-CXVCJ-9G2XF-6Q84J</td>
</tr>
</tbody></table>
<p>Windows服务器级：</p>
<p>老版本：Windows Server 2003、2008R2、2012R2、2016、2019、2022</p>
<p>Windows Server 2022版本：标准版、数据中心版</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>KMS序列号</th>
</tr>
</thead>
<tbody><tr>
<td>标准版</td>
<td>RGN6B-MCPWX-6K6GK-HKM33-7VCXY</td>
</tr>
<tr>
<td>数据中心版</td>
<td>DNVBD-FCT8Y-TQT8Q-HGQ34-QGRRV</td>
</tr>
</tbody></table>
<h2 id="Linux操作系统"><a href="#Linux操作系统" class="headerlink" title="Linux操作系统"></a>Linux操作系统</h2><table>
<thead>
<tr>
<th>发行版</th>
<th>包管理器</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>CentOS</td>
<td>yum&#x2F;rpm</td>
<td>截止CentOS 7版本仍是很优秀的稳定系统，但是自8版本后已不再适合做为服务器系统使用</td>
</tr>
<tr>
<td>Debian</td>
<td>apt&#x2F;deb</td>
<td>Linux系统先驱者，最著名的Linux发行版，及其稳定，庞大的软件库，自由软件支持，强大的社区支持，多架构支持，<strong>十分推荐做为服务器和桌面操作系统</strong></td>
</tr>
<tr>
<td>Ubuntu</td>
<td>apt&#x2F;deb</td>
<td>作为服务器系统使用有点难评，不如Debian，但是做为桌面操作系统还是可以的</td>
</tr>
<tr>
<td>Arch</td>
<td>pacman&#x2F;yay</td>
<td>Linux折腾界的No.1，新手入门练习必备，从grub到lvm分区全方位了解Linux，也是做为桌面操作系统的一大神器，yay源软件包丰富到无法形容</td>
</tr>
<tr>
<td>Kali</td>
<td>apt&#x2F;deb</td>
<td>最著名的渗透测试、数字取证系统，内置大量安全测试工具和程序，支持多种架构</td>
</tr>
<tr>
<td>UOS</td>
<td>apt&#x2F;deb</td>
<td>国产统信，也就那样</td>
</tr>
<tr>
<td>Deepin</td>
<td>apt&#x2F;deb</td>
<td>国产深度，也就那样</td>
</tr>
<tr>
<td>Kylin</td>
<td>apt&#x2F;deb</td>
<td>我反正是不得用</td>
</tr>
<tr>
<td>Kylin服务器版</td>
<td>yum&#x2F;rpm</td>
<td>更不得用</td>
</tr>
<tr>
<td>EularOS</td>
<td>yum&#x2F;rpm</td>
<td>华为推出的，为啥不直接用CentOS呢？</td>
</tr>
</tbody></table>
<h2 id="板载RAID问题"><a href="#板载RAID问题" class="headerlink" title="板载RAID问题"></a>板载RAID问题</h2><p>板载RAID通常使用的是Intel VROC技术，该技术仅支持部分Windows，完全不支持Linux，如果用户需要在Linux使用RAID，需配备RAID卡，或考虑mdadm、ZFS软RAID</p>
<p><strong>建议对Linux系统选配RAID卡，如LSI 9364-8i</strong></p>
<h2 id="RAID-x2F-HBA卡知识"><a href="#RAID-x2F-HBA卡知识" class="headerlink" title="RAID&#x2F;HBA卡知识"></a>RAID&#x2F;HBA卡知识</h2><p>以LSI RAID卡为例</p>
<p>LSI 9364-8i，其中93是RAID卡芯片版本，64则是型号，8i则是接口，8代表支持8个端口（硬盘）也就是两个SFF-8643，i表示内部，如果是e则是外接的扩展卡，常见于HBA</p>
<p>以LSI HBA卡为例</p>
<p>LSI 9300-8e，如上所述，8e代表可外接8个port，也就是两个SFF-8644</p>
<p>HBA直通卡有IR&#x2F;IT两种模式，IT(Initiator Target)是纯直通模式，呈现给系统的盘就是一个个独立磁盘；IR(Integrated RAID)模式则是卡自身支持基础的RAID 0&#x2F;1&#x2F;5，但是RAID 5通常性能低下，一般选用IT卡即可。</p>
<p>IT卡：LSI 9300-8i<br>IR卡：LSI 9311-8i</p>
<p>RAID卡的缓存：频繁读写的热数据会加载到RAID卡缓存中，这样可以大幅提升热数据的读写速度，但是缓存掉电丢失，所以如果要启用回写模式，必须配备BBU（RAID超级电容、电池），也可以采用SSD缓存盘的方式实现掉电不掉数据，但是缓存+BBU是最好的方案</p>
<h2 id="交换机、路由器等知识"><a href="#交换机、路由器等知识" class="headerlink" title="交换机、路由器等知识"></a>交换机、路由器等知识</h2><p>交换机通常分为：二层交换机、三层交换机、核心交换机</p>
<p>二层交换机也叫傻瓜式交换机，插电接线就能用，常作为接入交换机使用</p>
<p>三层交换机则是具有管理功能，可以配置VLAN、静态路由、DHCP、ACL策略等数据链路层面功能，可以根据业务需求设置一些规则，能满足大部分业务场景</p>
<p>核心交换机则具有更大的交换容量，更高的性能，通常还支持堆叠（交换机虚拟化）功能，将多台交换机组合模拟成一台交换机，便于运维等</p>
<p>路由器则是负责WAN（广域网）和LAN（局域网）的连通，如拨号上网，DHCP，上网策略，终端管控，AP管理，NAT转发等数据包层面的功能</p>
<p>除此之外，还有上网行为管理设备，其作用如同字面意思，对上网流量进行监督、管控，识别用户的上网行为，判断其流量访问了什么网站，发送了什么消息，该设备对于隐私方面存在一些争议</p>
<p>其他的园区交换机，ONU等通常不会涉及，在此不做介绍，可以自行在网上了解</p>
<h2 id="常见文件系统"><a href="#常见文件系统" class="headerlink" title="常见文件系统"></a>常见文件系统</h2><p>fat32：U盘常用，兼容性好，单文件不能超过4GB</p>
<p>NTFS：Windows常用，支持大文件，大容量</p>
<p>ext4：Linux常用，稳定性好，支持大文件大容量</p>
<p>xfs：Linux常用，比ext4更高性能更好，支持更大容量，具有优秀的可扩展性</p>
<p>zfs：开源高级文件系统，支持大容量，拥有独特的RAID-Z软RAID，支持快照，写时复制，自修复等特性，常用于数据量很大的服务器或存储</p>
<p>APFS：苹果的存储系统，只适合苹果用（玩垄断，辣鸡！）</p>
]]></content>
      <categories>
        <category>知识库</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>IT知识</tag>
        <tag>百科</tag>
      </tags>
  </entry>
</search>
